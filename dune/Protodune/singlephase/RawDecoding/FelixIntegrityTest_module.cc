// art includes
#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
#include "art/Framework/Services/Registry/ServiceHandle.h"
#include "art_root_io/TFileService.h"

// artdaq and dune-raw-data includes
#include "dune-raw-data/Overlays/FelixFragment.hh"
#include "artdaq-core/Data/Fragment.hh"
#include "artdaq-core/Data/ContainerFragment.hh"
#include "dune-raw-data/Overlays/FragmentType.hh"
#include "dune-raw-data/Services/ChannelMap/PdspChannelMapService.h"

// larsoft includes
#include "lardataobj/RawData/RawDigit.h"

// ROOT includes
#include "TH1.h"

// C++ Includes
#include <memory>
#include <iostream>

namespace dune {
  class FelixIntegrityTest;
}

class dune::FelixIntegrityTest : public art::EDAnalyzer {
public:
  explicit FelixIntegrityTest(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resoufelix use.

  // Plugins should not be copied or assigned.
  FelixIntegrityTest(FelixIntegrityTest const &) = delete;
  FelixIntegrityTest(FelixIntegrityTest &&) = delete;
  FelixIntegrityTest & operator = (FelixIntegrityTest const &) = delete;
  FelixIntegrityTest & operator = (FelixIntegrityTest &&) = delete;

  // Required functions.
  void analyze(const art::Event & evt) override;
  void beginJob() override;

private:
  typedef std::vector<raw::RawDigit> RawDigits;

  bool _process(const artdaq::Fragment& frag);

  // Declare member data here.
  std::string _input_label;
  bool _expect_container_fragments;
};


dune::FelixIntegrityTest::FelixIntegrityTest(fhicl::ParameterSet const & pset)
  : EDAnalyzer(pset),
    _input_label(pset.get<std::string>("RawDataLabel")),
    _expect_container_fragments(pset.get<bool>("ExpectContainerFragments", true)) {}

void dune::FelixIntegrityTest::beginJob(){
}

void dune::FelixIntegrityTest::analyze(const art::Event & evt){
    MF_LOG_INFO("FelixIntegrityTest")
      << "-------------------- FELIX Integrity Test -------------------";

  unsigned int n_felix_frags = 0;

  if (_expect_container_fragments) {
    art::Handle<artdaq::Fragments> cont_frags;
    evt.getByLabel(_input_label, "ContainerFELIX", cont_frags);
    art::EventNumber_t eventNumber = evt.event();
    // Check if there is Timing data in this event
    // Don't crash code if not present, just don't save anything
    try { cont_frags->size(); }
    catch(std::exception e) {
      std::cout << "WARNING: Container FELIX data not found in event " << eventNumber << std::endl;
      return;
    }
    //Check that the data is valid
    if(!cont_frags.isValid()){
      MF_LOG_ERROR("FelixIntegrityTest")
          << "Run: " << evt.run()
          << ", SubRun: " << evt.subRun()
          << ", Event: " << evt.event()
          << " Container Fragments is NOT VALID";
    }

    for (auto const& cont : *cont_frags)
    {
      artdaq::ContainerFragment cont_frag(cont);
      for (size_t ii = 0; ii < cont_frag.block_count(); ++ii)
      {
        if (_process(*cont_frag[ii])) ++n_felix_frags;
      }
    }
  }
  else
  {
    art::Handle<artdaq::Fragments> frags;
    evt.getByLabel(_input_label, "FELIX", frags);
    // Check if there is Timing data in this event
    // Don't crash code if not present, just don't save anything
    art::EventNumber_t eventNumber = evt.event();
    try { frags->size(); }
    catch(std::exception e) {
      std::cout << "WARNING: Raw FELIX data not found in event " << eventNumber << std::endl;
      return;
    }

    //Check that the data is valid
    if(!frags.isValid()){
      MF_LOG_ERROR("FelixIntegrityTest")
          << "Run: " << evt.run()
          << ", SubRun: " << evt.subRun()
          << ", Event: " << evt.event()
          << " Fragments is NOT VALID";
    }

    for(auto const& frag: *frags)
    {
      if (_process(frag)) ++n_felix_frags;
    }
  }

  MF_LOG_INFO("FelixIntegrityTest")
      << " Processed " << n_felix_frags
      << " FELIX Fragments";
}

bool dune::FelixIntegrityTest::_process(const artdaq::Fragment& frag)
{
  MF_LOG_INFO("FelixIntegrityTest")
      << "   SequenceID = " << frag.sequenceID()
      << "   fragmentID = " << frag.fragmentID()
      << "   fragmentType = " << (unsigned)frag.type()
      << "   Timestamp =  " << frag.timestamp();
  //Load overlay class.
  dune::FelixFragment felix(frag);
  //Get detector element number
  uint8_t crate = felix.crate_no(0);
  uint8_t slot = felix.slot_no(0);
  uint8_t fiber = felix.fiber_no(0); // two numbers?
  const unsigned n_frames = felix.total_frames(); // One frame contains 20 ticks.
  std::cout<<" Nframes = "<<n_frames<<std::endl;
  const unsigned n_channels = dune::FelixFrame::num_ch_per_frame;// 256
  // Fill the adc vector.
  for(unsigned ch = 0; ch < n_channels; ++ch) {
    std::cout<<"crate:slot:fiber = "<<crate<<", "<<slot<<", "<<fiber<<std::endl;
    std::vector<dune::adc_t> waveform( felix.get_ADCs_by_channel(ch) );
    for(unsigned int nframe=0;nframe<waveform.size();nframe++){
      if(ch==0 && nframe<100) {
        if(nframe==0) std::cout<<"Print the first 100 ADCs of Channel#1"<<std::endl;
        std::cout<<waveform.at(nframe)<<"  ";
        if(nframe==99) std::cout<<std::endl;
      }
    }
  }
  return true;
}

DEFINE_ART_MODULE(dune::FelixIntegrityTest)
