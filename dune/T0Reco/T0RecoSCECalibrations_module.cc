////////////////////////////////////////////////////////////////////////
// Class:       T0RecoSCECalibrations
// Module Type: analyzer
// File:        T0RecoSCECalibrations_module.cc
//
//
// Hannah Rogers   - hannah.rogers@colostate.edu
// based on uboonecode modules by David Caratelli and Chris Barnes
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "canvas/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
#include "art/Framework/Services/Optional/TFileService.h"

// services etc...
#include "larcore/Geometry/Geometry.h"
#include "lardata/DetectorInfoServices/DetectorPropertiesService.h"

// data-products
#include "lardataobj/RecoBase/Track.h"
#include "lardataobj/RecoBase/Hit.h"
#include "lardataobj/RecoBase/OpFlash.h"
#include "lardataobj/RecoBase/OpHit.h"
#include "lardataobj/AnalysisBase/T0.h"
#include "lardata/Utilities/AssociationUtil.h"
#include "lardataobj/AnalysisBase/CosmicTag.h"
#include "lardataobj/MCBase/MCTrack.h"
#include "nusimdata/SimulationBase/MCTruth.h"
#include "nusimdata/SimulationBase/MCParticle.h"
#include "larsim/MCCheater/PhotonBackTrackerService.h"
#include "larsim/MCCheater/ParticleInventoryService.h"

// ROOT
#include "TVector3.h"
#include <TTree.h>

// C++
#include <memory>
#include <iostream>
#include <utility>

class T0RecoSCECalibrations;

class T0RecoSCECalibrations : public art::EDAnalyzer {
public:
	explicit T0RecoSCECalibrations(fhicl::ParameterSet const & p);
	// The destructor generated by the compiler is fine for classes
	// without bare pointers or other resource use.
	
	// Plugins should not be copied or assigned.
	T0RecoSCECalibrations(T0RecoSCECalibrations const &) = delete;
	T0RecoSCECalibrations(T0RecoSCECalibrations &&) = delete;
	T0RecoSCECalibrations & operator = (T0RecoSCECalibrations const &) = delete;
	T0RecoSCECalibrations & operator = (T0RecoSCECalibrations &&) = delete;
	
	void beginJob() override;
	
	//Required functions.
	void analyze(art::Event const & e) override;
	
private:

	// Delcare member data here.
	std::string fTrackProducer;
	std::string fT0Producer;
	std::string fFlashProducer;
	std::string fHitProducer;
	std::string fTriggerProducer;
	
	bool 	    fUseMC;
	double      fTPCResolution; // [cm]
	double      fDriftVelocity; // [cm/us]
	
	bool _debug;
	bool fCathode;
	bool fData;
	
	double _TOP, _BOTTOM, _FRONT, _BACK, _det_width; // [cm]
	
	std::vector<double> _flash_times;
	std::vector<size_t> _flash_id_v;
	
	double fTimeRes;
	
	double fPEmin;

	double fTDiffMax;
	
	double fRecoT0TimeOffset;
	
	//functions to be used throughout module
	bool   TrackEntersTop     (const std::vector<TVector3>& sorted_trk);
	bool   TrackEntersFront   (const std::vector<TVector3>& sorted_trk);
	bool   TrackEntersBack    (const std::vector<TVector3>& sorted_trk);
	bool   TrackEntersAnode   (const std::vector<TVector3>& sorted_trk, const int driftDir);
	bool   TrackEntersSide    (const std::vector<TVector3>& sorted_trk);
	bool   TrackExitsBottom   (const std::vector<TVector3>& sorted_trk);
	bool   TrackExitsFront    (const std::vector<TVector3>& sorted_trk);
	bool   TrackExitsBack     (const std::vector<TVector3>& sorted_trk);
	bool   TrackExitsAnode    (const std::vector<TVector3>& sorted_trk, const int driftDir);
	bool   TrackExitsSide     (const std::vector<TVector3>& sorted_trk);
  
	void   SortTrackPoints      (const recob::Track& track, std::vector<TVector3>& sorted_trk);
	void   SplitTrack(const recob::Track& track, std::vector<TVector3>& sorted_trk);
	
	double GetEnteringTimeCoord (const std::vector<TVector3>& sorted_trk);
	double GetExitingTimeCoord  (const std::vector<TVector3>& sorted_trk);
	
	size_t FlashMatch(const double reco_time);
	
	double MatchTracks(std::vector<TVector3>& sorted_trk, std::vector<TLorentzVector> mcpart);
  	std::vector<std::vector< TLorentzVector>> BuildMCParticleList(const art::Handle<std::vector<simb::MCParticle>>& mcpart_h, const double& fTPCResolution, const double& width);
  	
  	// Tree parameters
	TTree *_tree;
	double _mc_time;
	double _rc_time;
	double _flash_time;
	double _matched_flash_time;
	double _mc_matched_flash_time;
	double _dt_flash_reco;
	double _dt_mc_reco;
	double _dt_mc_flash;

	double _pe_flash;
	double _purity;	
	double _length;
	double _driftDir;
	bool _TPC_edge;

	double _rc_xs, _rc_xe, _rc_xs_corr, _rc_xe_corr;
	double _rc_ys, _rc_ye;
	double _rc_zs, _rc_ze;
	
	int _anode;
	int _cathode;
	int _sister_track;
	
	int _run, _subrun, _event, _track;
	
	TTree *_evTree;
	int _trk_ctr;
	int _ev_ctr;
	
};

T0RecoSCECalibrations::T0RecoSCECalibrations(fhicl::ParameterSet const & p)
	:
	EDAnalyzer(p)
{

	fTrackProducer     = p.get<std::string>("TrackProducer"    );
	fHitProducer       = p.get<std::string>("HitProducer"      );
	fFlashProducer     = p.get<std::string>("FlashProducer"    );
	fT0Producer        = p.get<std::string>("T0Producer"       );
	fTriggerProducer   = p.get<std::string>("TriggerProducer"  );
	fUseMC             = p.get<bool>       ("UseMC"            );
	fTPCResolution     = p.get<double>     ("Resolution"       );
	fTimeRes           = p.get<double>     ("TimeRes"          );
	fRecoT0TimeOffset  = p.get<double>     ("RecoT0TimeOffset" );
	fPEmin             = p.get<double>     ("PEmin"            );
	fTDiffMax     	   = p.get<double>     ("TDiffMax"         );
	fCathode           = p.get<bool>       ("CathodeOnly"      );
	_debug             = p.get<bool>       ("debug"            );
	fData              = p.get<bool>       ("Data"             );
	
	
	// get boundaries based on detector bounds
	auto const* geom = lar::providerFrom<geo::Geometry>();
  
	_TOP = fTPCResolution;
	_BOTTOM = fTPCResolution;
	_FRONT = fTPCResolution;
	_BACK = fTPCResolution;

	for (geo::TPCID const& tID: geom->IterateTPCIDs()) {
		geo::TPCGeo const& TPC = geom->TPC(tID);
   
		if(TPC.DriftDistance() < 25.0) continue;
   
		double origin[3] = {0.};
		double center[3] = {0.};
		TPC.LocalToWorld(origin, center);
   
		double top = center[1] + TPC.HalfHeight() - fTPCResolution;
		double bottom = center[1] - TPC.HalfHeight() + fTPCResolution;
		double front = center[2] - TPC.HalfLength() + fTPCResolution;
		double back = center[2] + TPC.HalfLength() - fTPCResolution;
   
		if (top > _TOP) _TOP = top;
		if (bottom < _BOTTOM) _BOTTOM = bottom;
		if (front < _FRONT) _FRONT = front;
		if (back  > _BACK) _BACK = back;  
   
		_det_width = TPC.DriftDistance();
	}
  
	// Use '_detp' to find 'efield' and 'temp'
	auto const* _detp = lar::providerFrom<detinfo::DetectorPropertiesService>();
	double efield = _detp -> Efield();
	double temp   = _detp -> Temperature();
	// Determine the drift velocity from 'efield' and 'temp'
	fDriftVelocity = _detp -> DriftVelocity(efield,temp);
}  
  
void T0RecoSCECalibrations::beginJob(){

	art::ServiceHandle<art::TFileService> tfs;
	_tree = tfs->make<TTree>("_tree","SCE calibrations variables");
	_tree->Branch("_mc_time",&_mc_time,"mc_time/D");
	_tree->Branch("_rc_time",&_rc_time,"rc_time/D");
	_tree->Branch("_flash_time",&_flash_time,"flash_time/D");	
	_tree->Branch("_matched_flash_time",&_matched_flash_time,"matched_flash_time/D");
	_tree->Branch("_mc_matched_flash_time",&_mc_matched_flash_time,"mc_matched_flash_time/D");
	_tree->Branch("_dt_flash_reco",&_dt_flash_reco,"dt_flash_reco/D");
	_tree->Branch("_dt_mc_reco",&_dt_mc_reco,"dt_mc_reco/D");
	_tree->Branch("_dt_mc_flash",&_dt_mc_flash,"dt_mc_flash/D");
	_tree->Branch("_pe_flash",&_pe_flash,"pe_flash/D");
	_tree->Branch("_purity",&_purity,"purity/D");
	_tree->Branch("_length", &_length, "length/D");
	_tree->Branch("_TPC_edge",&_TPC_edge,"TPC_edge/B");
	_tree->Branch("_driftDir",&_driftDir,"driftDir/I");
	// Add branches for the first and last x, y, and z coordinates of the rc tracks and the mc tracks
	_tree->Branch("_rc_xs",&_rc_xs,"rc_xs/D");
	_tree->Branch("_rc_xs_corr",&_rc_xs_corr,"rc_xs/D");
	_tree->Branch("_rc_ys",&_rc_ys,"rc_ys/D");
	_tree->Branch("_rc_zs",&_rc_zs,"rc_zs/D");
	_tree->Branch("_rc_xe",&_rc_xe,"rc_xe/D");
	_tree->Branch("_rc_xe_corr",&_rc_xe_corr,"rc_xe_corr/D");
	_tree->Branch("_rc_ye",&_rc_ye,"rc_ye/D");
	_tree->Branch("_rc_ze",&_rc_ze,"rc_ze/D");
	// information on whether track enters/exits which sides
	_tree->Branch("_anode"  ,&_anode,"anode/I"  );
	_tree->Branch("_cathode",&_cathode,"cathode/I");
	_tree->Branch("_sister_track",&_sister_track,"sister_track/I");
	_tree->Branch("_run",&_run,"run/I");
	_tree->Branch("_subrun",&_subrun,"subrun/I");
	_tree->Branch("_event",&_event,"event/I");
	_tree->Branch("_track",&_track,"track/I");
	
	_evTree = tfs->make<TTree>("_evTree","Event information");
	_evTree->Branch("_trk_ctr",&_trk_ctr,"trk_ctr/I");
	_evTree->Branch("_ev_ctr",&_ev_ctr,"ev_ctr/I");
	_ev_ctr = 0;
	_trk_ctr = 0;
	
}
  
void T0RecoSCECalibrations::analyze(art::Event const & e){

	_event = e.event();
	_subrun = e.subRun();
	_run = e.run();
	_track = 0;
	_ev_ctr++;
	
	std::vector<std::vector<TLorentzVector>> mcpart_list;
	
	std::cout << "Event number: " << _ev_ctr << std::endl;
	if(_debug) std::cout << "Set event number: " << _event << "top: " << _TOP << "\nbottom: " << _BOTTOM 
	<< "\nfront: " << _FRONT << "\nback: " << _BACK << std::endl;  
  
  
	_flash_times.clear();
	_flash_id_v.clear();
	
	// load Flash
	if (_debug) { std::cout << "loading flash from producer " << fFlashProducer << std::endl; }
	art::Handle<std::vector<recob::OpFlash> > flash_h;
	if(!fCathode){
	e.getByLabel(fFlashProducer,flash_h);

	// make sure flash look good
	if(!flash_h.isValid()) {
		std::cerr<<"\033[93m[ERROR]\033[00m ... could not locate Flash!"<<std::endl;
    	throw std::exception();
  	}
  	}
  	
  	if(_debug&&fData) std::cout << "loading trigger time from producer " << fTriggerProducer << std::endl;
  	art::Handle<std::vector<recob::OpFlash> > trigger_h;
	double trigger_time = 0;

  	if(fData){
  		e.getByLabel(fTriggerProducer, trigger_h);
  		trigger_time = trigger_h->at(0).Time();
  	}

  	// load tracks previously created for which T0 reconstruction should occur
  	if (_debug) { std::cout << "loading track from producer " << fTrackProducer << std::endl; }
  	art::Handle<std::vector<recob::Track> > track_h;
  	e.getByLabel(fTrackProducer,track_h);

  	// make sure tracks look good
  	if(!track_h.isValid()) {
   		std::cerr<<"\033[93m[ERROR]\033[00m ... could not locate Track!"<<std::endl;
    	throw std::exception();
  	}

  	std::vector<art::Ptr<recob::Track> > TrkVec;
  	art::fill_ptr_vector(TrkVec, track_h);

  	// grab 2d hits associated with tracks
  	art::FindMany<recob::Hit> trk_hit_assn_v(track_h, e, fHitProducer);

   // load MCParticles
	
	//auto mclist_h = e.getValidHandle<std::vector<simb::MCTruth> >("generator");
  	art::Handle<std::vector<simb::MCParticle> > mcpart_h;
  	//e.getByLabel("largeant",mcpart_h);

  	// if we should use MCParticle
  	if (fUseMC){
		// make sure particles exist
		if(!mcpart_h.isValid()) {
			std::cerr<<"\033[93m[ERROR]\033[00m ... could not locate MCParticle!"<<std::endl;
			throw std::exception(); }

		mcpart_list = BuildMCParticleList(mcpart_h,fTPCResolution,_det_width);
		// Get all the MC particle ids.
		/*std::set<int> particleIDs;
	  	art::FindManyP<simb::MCParticle> geantAssns(mclist_h,e,"largeant");
	  	for ( size_t i = 0; i < geantAssns.size(); i++) {
	      	auto parts = geantAssns.at(i);
	      	for (auto part = parts.begin(); part != parts.end(); part++) {
	        particleIDs.emplace((*part)->TrackId()); }*/
	

   	}

	// ^ if use MCParticle

  	// grab T0 objects associated with tracks
  	art::FindMany<anab::T0> trk_t0_assn_v(track_h, e, fT0Producer );

	// Prepare a vector of optical flash times, if flash above some PE cut value

	if(!fCathode){
  	size_t flash_ctr = 0;
  	for (auto const& flash : *flash_h){
    	if (flash.TotalPE() > fPEmin){
      		_flash_times.push_back(flash.Time() - trigger_time);
      		_flash_id_v.push_back(flash_ctr);
		_flash_time = flash.Time();
		_tree->Fill();
      		if (_debug) std::cout << "\t Flash: " << flash_ctr << " has time : " << flash.Time() - trigger_time << ", PE : " 
		<< flash.TotalPE() << std::endl;
   		}
    	flash_ctr++;
  	}// for all flashes
  
   	if (_debug) { std::cout << "Selected a total of " << _flash_times.size() << " OpFlashes" << std::endl; }
	}
  
	// loop through reconstructed tracks
	size_t trk_ctr = -1;

	for (auto& track : TrkVec){ 
		trk_ctr ++;
		_trk_ctr ++;
		if (_debug) std::cout << "Looping through reco track " << trk_ctr << std::endl;  
  
		const std::vector<const recob::Hit*>& Hit_v = trk_hit_assn_v.at(trk_ctr);
		
		//_rc_time = 9999.;
		//_matched_flash_time = -9999.;
		//_mc_time = 9999.;
		//_dt_flash_reco = -9999.;
		//_dt_mc_reco = -9999.;
		//_dt_mc_flash = -9999.;

		_pe_flash = 0.;
		_purity = 0.;
		_length = 0.;
		_driftDir = 0;

		//_rc_xs = 999.;
		//_rc_xe = 999.; 
		//_rc_xs_corr = 999.;
		//_rc_xe_corr = 999.;
		//_rc_ys = 999.;
		//_rc_ye = 999.; 
		//_rc_zs = 999.; 
		//_rc_ze = 999.;

		_anode = 0;
		_cathode = 0;
		_sister_track = 0;
		_TPC_edge = false;
	
  
 		// get sorted points for the track object [assuming downwards going]
    		std::vector<TVector3> sorted_trk;
	    	SortTrackPoints(*track,sorted_trk);
	    	if(_debug) std::cout << "\tTrack goes from (" << sorted_trk.at(0).X() << ", " << sorted_trk.at(0).Y() << ", " << sorted_trk.at(0).Z() << ") --> (" << sorted_trk.at(sorted_trk.size()-1).X() << ", " << sorted_trk.at(sorted_trk.size()-1).Y() << ", " << sorted_trk.at(sorted_trk.size()-1).Z() << ")" << std::endl;
      
	      	 if( sqrt(pow(sorted_trk.at(0).X() - sorted_trk.at(sorted_trk.size()-1).X(),2.0) + pow(sorted_trk.at(0).Y() - sorted_trk.at(sorted_trk.size()-1).Y(),2.0) + pow(sorted_trk.at(0).Z() - sorted_trk.at(sorted_trk.size()-1).Z(),2.0)) < 50 )
		{
      			if(_debug) std::cout << "\tTrack too short. Skipping." << std::endl;
      			continue;
	      	}

     		// Determine if the track crosses the cathode 
    		auto const* geom = lar::providerFrom<geo::Geometry>();   
    		auto const* hit = Hit_v.at(0);
	    	const geo::WireID wireID = hit->WireID();
		const auto TPCGeoObject = geom->TPC(wireID.TPC,wireID.Cryostat);
		short int driftDir = TPCGeoObject.DetectDriftDirection();
		bool cross_cathode = false;
	    	for (size_t ii = 1; ii < Hit_v.size(); ii++) {
    			const geo::WireID wireID2 = Hit_v.at(ii)->WireID();
			const auto TPCGeoObject2 = geom->TPC(wireID2.TPC,wireID2.Cryostat);
			short int driftDir_tmp = TPCGeoObject2.DetectDriftDirection(); 
		
			if(driftDir_tmp + driftDir == 0){
				cross_cathode = true;
				if(_debug) std::cout << "\tCrosses cathode!" << std::endl;
				//continue;
				ii = Hit_v.size();
			}
		}
		if(_debug) std::cout << "\tCross cathode = " << cross_cathode << std::endl;
		
	
	// -------------------------------------------------------------------------------
	//CATHODE CROSSERS
		if(cross_cathode){ 
			_anode = 0;
			_cathode = 1;
		
			//const std::vector<const anab::T0*>& T0_v = trk_t0_assn_v.at(trk_ctr);
			//auto t0 = T0_v.at(0);
			//_rc_time = t0->Time();
		
    	
    			SplitTrack(*track,sorted_trk);
    			std::vector<TVector3> top_trk = {sorted_trk.at(0), sorted_trk.at(1)};
	    		std::vector<TVector3> bottom_trk = {sorted_trk.at(2), sorted_trk.at(3)};
    	
		    	if(_debug)std::cout << "\tCathode-crossing track from (" << top_trk.at(0).X() << ", " << top_trk.at(0).Y() << ", " << top_trk.at(0).Z() << ") --> (" << top_trk.at(1).X() << ", " << top_trk.at(1).Y() << ", " << top_trk.at(1).Z() << ") --> (" << bottom_trk.at(0).X() << ", " << bottom_trk.at(0).Y() << ", " << bottom_trk.at(0).Z() << ") --> (" << bottom_trk.at(1).X() << ", " << bottom_trk.at(1).Y() << ", " << bottom_trk.at(1).Z() << ")" << std::endl;
    	
    			// Top Track!
		    	if(_debug) std::cout << "\tTop track" << std::endl;
    	
    			_sister_track = _track + 1;
		    	auto const &top = top_trk.at(0);
	    		auto const &bottom = top_trk.at(1);
		
			_rc_xs = top.X();
			_rc_xs_corr = _rc_xs;
    			_rc_ys = top.Y();
    			_rc_zs = top.Z();
    			_rc_xe = bottom.X();
    			_rc_xe_corr = _rc_xe;
    			_rc_ye = bottom.Y();
    			_rc_ze = bottom.Z();
    	
			_length = sqrt(pow(_rc_xs - _rc_xe,2.0) + pow(_rc_ys - _rc_ye,2.0) + pow(_rc_zs - _rc_ze,2.0));
			if(_rc_xs<0.0) _driftDir = -1;
			else _driftDir = 1;
		
			_tree->Fill();
			_track++;
		
			// Bottom Track
			if(_debug) std::cout << "\tBottom track" << std::endl;
			_sister_track = _track - 1;
		
			auto const &top2 = bottom_trk.at(0);
		    	auto const &bottom2 = bottom_trk.at(1);
		
			_rc_xs = top2.X();
			_rc_xs_corr = _rc_xs;
    			_rc_ys = top2.Y();
    			_rc_zs = top2.Z();
    			_rc_xe = bottom2.X();
    			_rc_xe_corr = _rc_xe;
    			_rc_ye = bottom2.Y();
    			_rc_ze = bottom2.Z();
    	
			_length = sqrt(pow(_rc_xs - _rc_xe,2.0) + pow(_rc_ys - _rc_ye,2.0) + pow(_rc_zs - _rc_ze,2.0));
			if(_rc_xs<0.0) _driftDir = -1;
			else _driftDir = 1;
		
			_tree->Fill();
			_track++;
			}
		
		// ------------------------------------------------------------------------------------
		// ANODE PIERCERS 
		else{
			if(fCathode) {std::cout << "\tSKIPPING ANODE-PEIRCING TRACKS" << std::endl; continue;}
	
			if(_debug) std::cout << "\t\tThis track starts in TPC " << wireID.TPC << " which has a drift direction of " << driftDir << std::endl; 
			_driftDir = driftDir;
	
			// create root trees variables
    			auto const &top = sorted_trk.at(0);
   			auto const &bottom = sorted_trk.at(1);
    
   			_rc_xs = top.X();
		  	_rc_ys = top.Y();
		  	_rc_zs = top.Z();
	    		_rc_xe = bottom.X();
	    		_rc_ye = bottom.Y();
    			_rc_ze = bottom.Z();
    			_length = track->Length();

    			// keep track of whether it goes thorugh the anode or cathode
    			_anode = 0, _cathode = 0;

    			// 1st category: tracks which ENTER SIDE
    			if ( TrackEntersSide(sorted_trk) == true ) {

			     	if (_debug) std::cout << "\t track enters side" << std::endl;
	
			    	// we are not done. We need to check that the track either: 1) Exits the bottom. 2) exits the front or 3) exits the back of the TPC.
			   	bool tagged = false;

				// tracks that exit the bottom
      				if ( (TrackExitsBottom(sorted_trk) == true) ) {
				tagged = true;
				if (_debug) std::cout << "\t track exits bottom" << std::endl;
			      	}
      			// tracks that exit the front
      			if ( (TrackExitsFront(sorted_trk) == true) and (TrackEntersFront(sorted_trk) == false)) {
				tagged = true;
				if (_debug) std::cout << "\t track exits front" << std::endl;
      				}
      			// tracks that exit the back
      			if ( (TrackExitsBack(sorted_trk) == true) and (TrackEntersBack(sorted_trk) == false) ) {
				tagged = true;
				if (_debug) std::cout << "\t track exits back" << std::endl;
      				}

      			// have any of these 3 conditions been met? if no, skip this track
      			if (tagged == false) continue;
      
      			// figure out if it enters the anode or cathode
      			bool enters_anode = TrackEntersAnode(sorted_trk, driftDir);
      
      			// get the X coordinate of the point piercing the anode/cathode (upon ENTERING) 
      			double trkX = GetEnteringTimeCoord(sorted_trk);
      
      			// reconstruct track T0 w.r.t. trigger time

      // The 'trkX' enters on the anode, the side of the TPC with a lower x value than the cathode
      if (enters_anode){
	_rc_time = (_det_width - (double)driftDir * trkX) / fDriftVelocity + fRecoT0TimeOffset;
	if(_debug) std::cout << "\tTrack enters anode. " << _rc_time << "  = ( " << _det_width << " - " << driftDir*trkX << ") / " << fDriftVelocity << std::endl;
	_anode = 1;
      }

    }// if the track enters the side

    // case in which the track exits the side
    if (TrackExitsSide(sorted_trk) == true) {

      if (_debug) std::cout << "\t track exits side" << std::endl;

      // we are not done. We need to check that the track either: 1) Enters the bottom. 2) enters the front
      // or 3) enters the back of the TPC.
      bool tagged = false;

      // track enters the top
      if ( (TrackEntersTop(sorted_trk) == true) ) {       
	tagged = true;
	if (_debug) std::cout << "\t track enters the top" << std::endl;
      }

      if ( (TrackEntersFront(sorted_trk) == true) and (TrackExitsFront(sorted_trk) == false)) {
	tagged = true;
	if (_debug) std::cout << "\t track enters front" << std::endl;
      }

      if ( (TrackEntersBack(sorted_trk) == true) and (TrackExitsBack(sorted_trk) == false)  ) {
	tagged = true;
	if (_debug) std::cout << "\t track enters back" << std::endl;
      }

      // has either of these 3 conditions been met? if no, skip this track
      if (tagged == false) continue;
      // figure out if it enters the anode or cathode
      bool exits_anode = TrackExitsAnode(sorted_trk, driftDir);
      
      // get the X coordinate of the point piercing the anode/cathode (upon ENTERING) 
      double trkX = GetExitingTimeCoord(sorted_trk);
      
      // reconstruct track T0 w.r.t. trigger time

      // The 'trkX' enters on the anode, the side of the TPC with a lower x value than the cathode
      if (exits_anode){
	_rc_time = (_det_width - (double)driftDir * trkX) / fDriftVelocity + fRecoT0TimeOffset;
	if(_debug) std::cout << "\tTrack exits anode. " << _rc_time << "  = ( " << _det_width << " - " << driftDir*trkX << ") / " << fDriftVelocity << std::endl;
	_anode = 1;
      }

    }// if the track exits the side
	
	if(!_anode) continue; 
    

    if (_debug) std::cout << "\t this track has a reconstructed time = " << _rc_time << std::endl;
    
    _rc_xs_corr = _rc_xs + driftDir*_rc_time*fDriftVelocity;
    _rc_xe_corr = _rc_xe + driftDir*_rc_time*fDriftVelocity;
    
	// Determine if track hits edge of readout window
    bool TPC_edge = false;
    for (auto& hits : Hit_v){
    	auto peakHit = hits->PeakTime();
    	//if(_debug) std::cout << "\t\tHit time track " << trk_ctr << ": " << peakHit << " in TPC " << hits->WireID().TPC << " plane " << hits->WireID().Plane << " and wire " << hits->WireID().Wire << std::endl;
    	if( (peakHit > 6000.0 - 50.0) || (peakHit < 50.0) ){
    	 TPC_edge = true;
    	 //if(_debug) std::cout << "\t\tHit time out of range: " << peakHit << std::endl;
    	}
    }
    
    if (TPC_edge) {
    	if(_debug) std::cout << "\tHit time too close to edge" << std::endl;
    	//continue;
    	_TPC_edge = true;
    }
	
    // flash matching
    auto const& flash_match_result = FlashMatch(_rc_time);
    const art::Ptr<recob::OpFlash> flash_ptr(flash_h, flash_match_result);
    if(_debug) std::cout << "\t matched to flash w/ index " << flash_match_result << " w/ PE " 
    << flash_ptr->TotalPE() << " and time " << flash_ptr->Time() - trigger_time << " vs reco time " 
    << _rc_time << std::endl;

    
    _pe_flash = flash_ptr->TotalPE();
    _matched_flash_time = flash_ptr->Time() - trigger_time;
    _dt_flash_reco = _matched_flash_time - _rc_time;
    
		 // if we should use MC info -> continue w/ MC validation
      if (fUseMC == true){
	// loop through MCParticles to find the one that matches.

	double _displacement = 1.0;
	  
	for (unsigned int j=0; j < mcpart_list.size(); j++){

	  std::vector<TLorentzVector> mcpart = mcpart_list.at(j);
	  
	  if(_debug) std::cout <<"\t\tMCParticle: (" << mcpart.at(0).X() << ", " << mcpart.at(0).Y() << ", " << mcpart.at(0).Z() <<
	  ") -> (" << mcpart.at(1).X() << ", " << mcpart.at(1).Y() << ", " << mcpart.at(1).Z() << ")" << std::endl;
	  
	  // try matching to MC
	  double _tmp_disp = MatchTracks(sorted_trk, mcpart);
	  if ((_tmp_disp > _displacement)||isnan(_tmp_disp))
	    continue;
	  
	  // matched -> get MCTrack time and reconstructed track reconstructed T0
	  _displacement = _tmp_disp;
	  _mc_time = mcpart.at(0).T() / 1000.;
	  _dt_mc_reco = _mc_time - _rc_time;

	  if(_debug) std::cout << "\tParticle number: " << j << " with sigma comparison value of " 
	  << _displacement << "\n\t\tTrack matched to MC value with t0 of " << _mc_time << 
	  " and reconstructed time of " << _rc_time << std::endl;

	    // flash matching to MC

	    art::ServiceHandle<cheat::PhotonBackTrackerService> pbt;
	    auto const& flash_match_mc = FlashMatch(_mc_time);
	    art::Ptr<recob::OpFlash> mc_flash_ptr (flash_h, flash_match_mc);
	    if(_debug)	std::cout << "MC particle " << j << " matched to flash w/ index " << flash_match_mc << 
	    " w/ PE " << mc_flash_ptr->TotalPE() << " and time " << mc_flash_ptr->Time() - trigger_time << 
	    " vs MC time " << _mc_time << std::endl;

	    //PhotonBackTracker for MC flash match purity
 	    std::vector< art::Ptr<recob::OpHit> > flash_hits = pbt->OpFlashToOpHits_Ps(mc_flash_ptr);
	    std::set<int> particleIDs;
	    particleIDs.emplace(j);
  	    _purity = pbt->OpHitCollectionPurity(particleIDs, flash_hits);

	    _mc_matched_flash_time = mc_flash_ptr->Time();
	    _dt_mc_flash = _mc_time - _mc_matched_flash_time;

	  
	} // for all MCParticles
      }// if we should use MCParticles
      
      if(abs(_dt_flash_reco) < fTDiffMax) _tree->Fill();
      
      _track++;
	
	}
    
    }
    
    _evTree->Fill();
}  
  
  double T0RecoSCECalibrations::MatchTracks(std::vector<TVector3>& sorted_trk, std::vector<TLorentzVector> mcpart)
{
  //assumes both the reco track
  //and mctrack are downwards going
  
  //auto const& mctrk_s = mcpart.at(0);
  //auto const& mctrk_e = mcpart.at(1);
  //auto const& track_s = sorted_trk.at(0);
  //auto const& track_e = sorted_trk.at(sorted_trk.size()-1);
  
  double mcX = mcpart.at(0).X(), mcY = mcpart.at(0).Y(), mcZ = mcpart.at(0).Z();
  double mcX_end = mcpart.at(1).X(), mcY_end = mcpart.at(1).Y(), mcZ_end = mcpart.at(1).Z();
  double trkX = sorted_trk.at(0).X(), trkY = sorted_trk.at(0).Y(), trkZ = sorted_trk.at(0).Z();
  double trkX_end = sorted_trk.at(sorted_trk.size()-1).X(), trkY_end = sorted_trk.at(sorted_trk.size()-1).Y(), trkZ_end = sorted_trk.at(sorted_trk.size()-1).Z();
  
  if(mcY<mcY_end){
  	double tmpX = mcX, tmpY = mcY, tmpZ = mcZ;
  	mcX = mcX_end;
  	mcY = mcY_end;
  	mcZ = mcZ_end;
  	mcX_end = tmpX;
  	mcY_end = tmpY;
  	mcZ_end = tmpZ;
  }
  
  double trkThXZ = atan((trkZ_end - trkZ)/(trkX_end - trkX));
  double trkThYZ = atan((trkZ_end - trkZ)/(trkY_end - trkY));
  double sigThXZ = sqrt(2.0)*fTPCResolution/sqrt(pow(trkZ_end-trkZ,2.0)+pow(trkX_end-trkX,2.0));
  double sigThYZ = sqrt(2.0)*fTPCResolution/sqrt(pow(trkZ_end-trkZ,2.0)+pow(trkY_end-trkY,2.0));
  double mcThXZ = atan((mcZ_end - mcZ)/(mcX_end - mcX));
  double mcThYZ = atan((mcZ_end - mcZ)/(mcY_end - mcY));
  
  return sqrt(pow((trkThXZ -  mcThXZ)/sigThXZ,2.0) + pow((trkThYZ -  mcThYZ)/sigThYZ,2.0) + pow((trkY - mcY)/fTPCResolution,2.0) + pow((trkZ - mcZ)/fTPCResolution,2.0))/4.0;

  
  
/*
  // if track start is above and mctrk start is above
  if ( ( track_s.Y() > track_e.Y() ) and ( mctrk_s.Y() > mctrk_e.Y() ) ){
    if ( (fabs(mctrk_s.Y()-track_s.Y()) < res) and (fabs(mctrk_s.Z()-track_s.Z()) < res) and (fabs(mctrk_e.Y()-track_e.Y()) < res) and (fabs(mctrk_e.Z()-track_e.Z()) < res) )
      return true;
  }
  // if track start is above and mctrk start is below
  if ( ( track_s.Y() > track_e.Y() ) and ( mctrk_s.Y() < mctrk_e.Y() ) ){
    if ( (fabs(mctrk_e.Y()-track_s.Y()) < res) and (fabs(mctrk_e.Z()-track_s.Z()) < res) and (fabs(mctrk_s.Y()-track_e.Y()) < res) and (fabs(mctrk_s.Z() - track_e.Z()) < res) )
      return true;
  }
  // if track start is below and mctrk start is above
  if ( ( track_s.Y() < track_e.Y() ) and ( mctrk_s.Y() > mctrk_e.Y() ) ){
    if ( (fabs(mctrk_s.Y()-track_e.Y()) < res) and (fabs(mctrk_s.Z()-track_e.Z()) < res) and (fabs(mctrk_e.Y()-track_s.Y()) < res) and (fabs(mctrk_e.Z()-track_s.Z()) < res) )
      return true;
  }
  // if track start is below and mctrk start is below
  if ( ( track_s.Y() < track_e.Y() ) and ( mctrk_s.Y() < mctrk_e.Y() ) ){
    if ( (fabs(mctrk_e.Y()-track_e.Y()) < res) and (fabs(mctrk_e.Z()-track_e.Z()) < res) and (fabs(mctrk_s.Y() - track_s.Y()) < res) and (fabs(mctrk_s.Z()-track_s.Z()) < res) )
      return true;
  }
  
  return false;
  */
}
  
  
size_t T0RecoSCECalibrations::FlashMatch(const double reco_time){
  
  // loop through all reco'd flash times and see if one matches
  // the time from the track/particle
  double dt_min = 20000.; // us
  size_t match_flash_id;

  for (size_t i=0; i < _flash_times.size(); i++){
    auto const& time = _flash_times[i];
    double dt = fabs(time - reco_time);
    if (dt < dt_min){
      dt_min  = dt;
      match_flash_id = _flash_id_v[i];
    }
  }

  return match_flash_id;
}


bool   T0RecoSCECalibrations::TrackEntersTop(const std::vector<TVector3>& sorted_trk)
{
  // check that the first point in the track
  // pierces the top boundary of the TPC
  // This track either will pierce the top of the TPC or is just about to (the '_TOP' variable is just below the actual coordinate position of the top in Y)

  if (sorted_trk.at(0).Y() > _TOP)
    return true;

  return false;
}


bool T0RecoSCECalibrations::TrackEntersFront(const std::vector<TVector3>& sorted_trk)
{

  // Determine if the track enters the
  // front of the TPC based on if the position
  // of its initial Z-coordinate is less than
  // the location of the front of the TPC in Z
  
  // First define 'top_pt' to mean the point at the start of the track
  auto const& top_pt = sorted_trk.at(0);

  if (top_pt.Z() < _FRONT)
    return true;

  // I may include the case in which I check
  // the y-coordinates as well, but I will not
  // implement that at this time
  
  // If this condition is not satisfied, then return 'false' (the track was not determined
  // within resolution to enter the front of the TPC)
  return false;
}


bool T0RecoSCECalibrations::TrackEntersBack(const std::vector<TVector3>& sorted_trk)
{

  // Determines if the track enters the
  // back of the TPC based on if the position
  // of its initial Z-coordinate is greater
  // than the location of the back of the
  // TPC in Z
  
  // First define 'top_pt' to mean the point at the start of the track
  auto const& top_pt = sorted_trk.at(0);

  if (top_pt.Z() > _BACK)
    return true;

  // If this condition is not satisfied, then return 'false' (the track was not determined
  // within resolution to enter the back of the TPC)
  return false;
}


bool   T0RecoSCECalibrations::TrackEntersAnode(const std::vector<TVector3>& sorted_trk, const int driftDir)
{

  // we know the track enters either the
  // anode or cathode
  // at this point figure out
  // if it ENTERS the ANODE or CATHODE
  // ANODE: top point must be at lower X-coord
  // than bottom point
  // CATHODE: top point must be at larger X-coord
  // than bottom point
  // assume track has already been sorted
  // such that the 1st point is the most elevated in Y coord.
  // return TRUE if passes the ANODE
  
  auto const& top    = sorted_trk.at(0);
  auto const& bottom = sorted_trk.at( sorted_trk.size() - 1 );

  if ( ( (top.X() < bottom.X()) && driftDir<0 ) || ( (top.X() > bottom.X()) && driftDir>0 ) )
    return true;

  return false;
}


bool   T0RecoSCECalibrations::TrackEntersSide(const std::vector<TVector3>& sorted_trk)
{
  
  // check that the top-most point
  // is not on the top of the TPC
  // nor on the front & back of the TPC
  
  auto const& top_pt = sorted_trk.at(0);

  // if highest point above the TOP -> false
  if (top_pt.Y() > _TOP)
    return false;

  // if highest point in Z close to front or back
  // -> FALSE
  if ( (top_pt.Z() < _FRONT) or (top_pt.Z() > _BACK) )
    return false;


  // If the function makes it this far, then it will enter through one of the sides of the TPC
  return true;
}


bool   T0RecoSCECalibrations::TrackExitsBottom(const std::vector<TVector3>& sorted_trk)
{

  // check that the last point in the track
  // pierces the bottom boundary of the TPC
  if ( sorted_trk.at( sorted_trk.size() - 1).Y() < _BOTTOM )
    return true;

  return false;
}


bool   T0RecoSCECalibrations::TrackExitsFront(const std::vector<TVector3>& sorted_trk)
{

  // Determine if the track exits the
  // front of the TPC based on if the position
  // of its final Z-coordinate is less than
  // the location of the front of the TPC in Z
  
  // First define 'bottom_pt' to mean the point at the end of the track
  auto const& bottom_pt = sorted_trk.at(sorted_trk.size() - 1);

  if (bottom_pt.Z() < _FRONT)
    return true;
  
  return false;
}


bool   T0RecoSCECalibrations::TrackExitsBack(const std::vector<TVector3>& sorted_trk)
{

  // Determine if the track exits the
  // front of the TPC based on if the position
  // of its final Z-coordinate is less than
  // the location of the front of the TPC in Z
  
  // First define 'bottom_pt' to mean the point at the end of the track
  auto const& bottom_pt = sorted_trk.at(sorted_trk.size() - 1);

  if (bottom_pt.Z() > _BACK)
    return true;

  return false;
}


bool   T0RecoSCECalibrations::TrackExitsAnode(const std::vector<TVector3>& sorted_trk, const int driftDir)
{

  // Check, once it's known that the track doesn't exit out of the bottom, whether it's the anode or
  // the cathode that it exits out of
  // This can be done by direct analogy with the 'Anode' function (shown in this file as the 'TrackEntersAnode') function written by D. Caratelli
  // Define 'top' as the point at the start of the track, and 'bottom' as the point at the end of the track

  auto const& top    = sorted_trk.at(0);
  auto const& bottom = sorted_trk.at(sorted_trk.size() - 1);

  // Check to see which point has a lower x coordinate
  // If the bottom does, then it exits out of the anode
  // If the top does, then it exits out of the cathode
  if ( ( (bottom.X() < top.X()) && driftDir<0 ) || ( (bottom.X() > top.X()) && driftDir>0 ) ) 
    return true;
	
  return false; // Otherwise, the top is less than the bottom, so the track ended closer to the cathode and exited there
}


bool   T0RecoSCECalibrations::TrackExitsSide(const std::vector<TVector3>& sorted_trk)
{

  // check that the bottom-most point
  // is not on the bottom of the TPC
  // nor on the front & back of the TPC

  auto const& bottom_pt = sorted_trk.at(sorted_trk.size() - 1);

  // if lowest point below the BOTTOM -> false
  // Within this resolution, this means that it's likely that the track exited out of the bottom (at a point earlier on in the process than the last point) OR is just about to

  if (bottom_pt.Y() <  _BOTTOM)
    return false;

  // if lowest point in Z close to front or back
  // -> FALSE
  // If the the bottom point is less than the front, then the track has already pierced the front of the TPC and exited that way OR is likely just about to
  // If the bottom point is greater than the back, then the track has already pierced the back of the TPC and exited that way OR is likely just about to
  if ( (bottom_pt.Z() < _FRONT) or (bottom_pt.Z() > _BACK) )
    return false;

  return true;
}

void T0RecoSCECalibrations::SplitTrack(const recob::Track& track, std::vector<TVector3>& sorted_trk){

	sorted_trk.clear();
	
	TVector3 track_neg, track_neg_c, track_pos_c,track_pos;
	double neg_x = 0.0;
	double pos_x = 0.0;
	double neg_c = -2.0*fTPCResolution;
	double pos_c = 2.0*fTPCResolution;
	
	for (size_t ii = 0; ii < track.NumberTrajectoryPoints(); ii++){
		auto const& trk_loc = track.LocationAtPoint(ii);
		
		if ((trk_loc.X() < -998.)||(trk_loc.Y() < -998.)||(trk_loc.Z() < -998)) continue;
		
		if (trk_loc.X() < neg_x){
			neg_x = trk_loc.X();
			track_neg = {trk_loc.X(), trk_loc.Y(), trk_loc.Z()};
		}
		if (trk_loc.X() > pos_x){
			pos_x = trk_loc.X();
			track_pos = {trk_loc.X(), trk_loc.Y(), trk_loc.Z()};
		}
		if ((trk_loc.X() < 0.0) && (trk_loc.X() > neg_c)){
			neg_c = trk_loc.X();
			track_neg_c = {trk_loc.X(), trk_loc.Y(), trk_loc.Z()};
		}
		if ((trk_loc.X() > 0.0) && (trk_loc.X() < pos_c)){
			pos_c = trk_loc.X();
			track_pos_c = {trk_loc.X(), trk_loc.Y(), trk_loc.Z()};
		}
	}
	
	if( track_neg.Y() > track_pos.Y()){
		sorted_trk.push_back(track_neg);
		sorted_trk.push_back(track_neg_c);
		sorted_trk.push_back(track_pos_c);
		sorted_trk.push_back(track_pos);
	} else {
		sorted_trk.push_back(track_pos);
		sorted_trk.push_back(track_pos_c);
		sorted_trk.push_back(track_neg_c);
		sorted_trk.push_back(track_neg);
	}
	
}

void   T0RecoSCECalibrations::SortTrackPoints(const recob::Track& track, std::vector<TVector3>& sorted_trk)
{
	sorted_trk.clear();
		
	TVector3 track_start, track_end;	
	double start_y = _BOTTOM - 2.0*fTPCResolution;
	double end_y = _TOP + 2.0*fTPCResolution;
	
	for (size_t ii = 0; ii < track.NumberTrajectoryPoints(); ii++){
		auto const& trk_loc = track.LocationAtPoint(ii);
		
		if ((trk_loc.X() < -998.)||(trk_loc.Y() < -998.)||(trk_loc.Z() < -998)) continue;
		
		if (trk_loc.Y() < end_y){
			end_y = trk_loc.Y();
			track_end = {trk_loc.X(), trk_loc.Y(), trk_loc.Z()};
		}
		if (trk_loc.Y() > start_y){
			start_y = trk_loc.Y();
			track_start = {trk_loc.X(), trk_loc.Y(), trk_loc.Z()};
		}
	}
	
	sorted_trk.push_back(track_start);
	sorted_trk.push_back(track_end);
	
/*  THIS METHOD ASSUMES THE TRACK IS SORTED AT ALL!!
  // vector to store 3D coordinates of
  // ordered track
  sorted_trk.clear();

  // take the reconstructed 3D track
  // and assuming it is downwards
  // going, sort points so that
  // the track starts at the top
  // which point is further up in Y coord?
  // start or end?
  auto const&N = track.NumberTrajectoryPoints();
  auto const&start = track.LocationAtPoint(0);
  auto const&end   = track.LocationAtPoint( N - 1 );

  // if points are ordered correctly
  if (start.Y() > end.Y()){
    for (size_t i=0; i < N; i++)
      sorted_trk.push_back( track.LocationAtPoint(i) );
  }
  
  // otherwise flip order
  else {
    for (size_t i=0; i < N; i++)
      sorted_trk.push_back( track.LocationAtPoint( N - i - 1) );
  }
*/
}


double T0RecoSCECalibrations::GetEnteringTimeCoord(const std::vector<TVector3>& sorted_trk)
{

  // get the drift-coordinate value
  // associated with the point
  // along the track piercing the anode / cathode
  // ** WHEN the track enters the anode / cathode
  return sorted_trk.at(0).X();
}


double T0RecoSCECalibrations::GetExitingTimeCoord(const std::vector<TVector3>& sorted_trk) 
{
  // get the drift-coordinate value
  // associated with the point
  // along the track piercing the anode / cathode
  // ** WHEN the track exits the anode / cathode
  return sorted_trk.at(sorted_trk.size() - 1).X();
}

std::vector<std::vector< TLorentzVector >> T0RecoSCECalibrations::BuildMCParticleList(const art::Handle<std::vector<simb::MCParticle> >& mcpart_h,const double& fTPCResolution, const double& width){

	std::vector<std::vector< TLorentzVector>> mcVec;

	for (size_t j=0; j < mcpart_h->size(); j++){
			
		auto const& mcpart = mcpart_h->at(j);
		
		double x0 = mcpart.Position(0).X();
		double y0 = mcpart.Position(0).Y();
		double z0 = mcpart.Position(0).Z();
		double t0 = mcpart.T(0);
		double x1 = mcpart.Position(mcpart.NumberTrajectoryPoints()-1).X();
		double y1 = mcpart.Position(mcpart.NumberTrajectoryPoints()-1).Y();
		double z1 = mcpart.Position(mcpart.NumberTrajectoryPoints()-1).Z();
		double t1 = mcpart.T(mcpart.NumberTrajectoryPoints()-1);
		
		//double xs = x0, ys = y0, zs = z0, ts = t0;
		//double xe = x1, ye = y1, ze = z1, te = t1;
		
		bool top_ok = false, bot_ok = false;
		//std::cout << mcpart.NumberTrajectoryPoints() << std::endl;
		if(mcpart.NumberTrajectoryPoints()<2900){
		for(size_t k = 0; k<mcpart.NumberTrajectoryPoints(); k++){
			if ((x0 > width) || (x0 < -width) || (y0 > _TOP + fTPCResolution) || (y0 < _BOTTOM - fTPCResolution) || (z0 < _FRONT - fTPCResolution) || (z0 > _BACK + fTPCResolution) ){
				x0 = mcpart.Position(k+1).X();
				y0 = mcpart.Position(k+1).Y();
				z0 = mcpart.Position(k+1).Z();
				t0 = mcpart.T(k+1);
			} else top_ok = true;

			if ((x1 > width) || (x1 < -width) || (y1 > _TOP + fTPCResolution) || (y1 < _BOTTOM - fTPCResolution) || (z1 < _FRONT - fTPCResolution) || (z1 > _BACK + fTPCResolution) ){
				x1 = mcpart.Position(mcpart.NumberTrajectoryPoints()-2-k).X();
				y1 = mcpart.Position(mcpart.NumberTrajectoryPoints()-2-k).Y();
				z1 = mcpart.Position(mcpart.NumberTrajectoryPoints()-2-k).Z();
				t1 = mcpart.T(mcpart.NumberTrajectoryPoints()-2-k);
			} else bot_ok = true;

			if(top_ok&&bot_ok) k = mcpart.NumberTrajectoryPoints();
		}
		}
			
		double xs = x0, ys = y0, zs = z0, ts = t0;
		double xe = x1, ye = y1, ze = z1, te = t1;
		
		TLorentzVector mc_top(TVector3(xs,ys,zs),ts);
		TLorentzVector mc_bot(TVector3(xe,ye,ze),te);
		//if (!top_ok||!bot_ok) continue;
		
		if (ys >  ye) mcVec.push_back({mc_top, mc_bot});
		else mcVec.push_back({mc_bot, mc_top});
		if(_debug) std::cout << " MCParticle: (" << x0 << ", " << y0 << ", " << z0 << ", " << t0/1000. << ") --> (" << xs << ", " << ys << ", " << zs << ", " << ts/1000.0 << ") --> (" << xe << ", " << ye << ", " << ze << ", " << te/1000.0 << ") --> (" << x1 << ", " << y1 << ", " << z1 << ", " << t1/1000.0 << ")" << std::endl;
		
	}
		return mcVec;	

}



DEFINE_ART_MODULE(T0RecoSCECalibrations) 
  
