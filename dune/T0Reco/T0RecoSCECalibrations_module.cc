////////////////////////////////////////////////////////////////////////
// Class:       T0RecoSCECalibrations
// Module Type: analyzer
// File:        T0RecoSCECalibrations_module.cc
//
// Joshua Thompson - joshua.l.thompson@sheffield.ac.uk
// developed from work by Hannah Rogers   - hannah.rogers@colostate.edu
// based on uboonecode modules by David Caratelli and Chris Barnes
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "canvas/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
#include "art/Framework/Services/Optional/TFileService.h"

// services etc...
#include "larcore/Geometry/Geometry.h"
#include "lardata/DetectorInfoServices/DetectorPropertiesService.h"
#include "lardata/DetectorInfoServices/DetectorClocksService.h"

// data-products
#include "lardataobj/RecoBase/Track.h"
#include "lardataobj/RecoBase/Hit.h"
#include "lardataobj/RecoBase/OpFlash.h"
#include "lardataobj/RecoBase/OpHit.h"
#include "lardataobj/AnalysisBase/T0.h"
#include "lardata/Utilities/AssociationUtil.h"
#include "lardataobj/AnalysisBase/CosmicTag.h"
#include "lardataobj/MCBase/MCTrack.h"
#include "nusimdata/SimulationBase/MCTruth.h"
#include "nusimdata/SimulationBase/MCParticle.h"
#include "larsim/MCCheater/PhotonBackTrackerService.h"
#include "larsim/MCCheater/ParticleInventoryService.h"
#include "dune/Protodune/Analysis/ProtoDUNEPFParticleUtils.h"
#include "dune/Protodune/Analysis/ProtoDUNETrackUtils.h"
#include "dune/Protodune/Analysis/ProtoDUNETruthUtils.h"

// ROOT
#include "TVector3.h"
#include <TTree.h>

// C++
#include <memory>
#include <iostream>
#include <utility>

class T0RecoSCECalibrations;

class T0RecoSCECalibrations : public art::EDAnalyzer {
public:
	explicit T0RecoSCECalibrations(fhicl::ParameterSet const & p);
	// The destructor generated by the compiler is fine for classes
	// without bare pointers or other resource use.
	
	// Plugins should not be copied or assigned.
	T0RecoSCECalibrations(T0RecoSCECalibrations const &) = delete;
	T0RecoSCECalibrations(T0RecoSCECalibrations &&) = delete;
	T0RecoSCECalibrations & operator = (T0RecoSCECalibrations const &) = delete;
	T0RecoSCECalibrations & operator = (T0RecoSCECalibrations &&) = delete;
	
	void beginJob() override;
	
	//Required functions.
	void analyze(art::Event const & e) override;
	
private:

	// Delcare member data here.
	std::string fTrackProducer;
	std::string fFlashProducer;
	std::string fHitProducer;
	std::string fTriggerProducer;
	std::string fPFPProducer;
	
	bool 	    fUseMC;
	double      fTPCResolution; // [cm]
	double      fDriftVelocity; // [cm/us]
	
	bool debug;
	bool fCathode;
	bool fAnode;
	bool fData;
	bool fAllFlash;
	
	double _TOP, _BOTTOM, _FRONT, _BACK, _det_width; // [cm]
	
	std::vector<double> _flash_times;
	std::vector<size_t> _flash_id_v;
	art::Handle<std::vector<recob::OpFlash> > flash_h;
	
	double fTimeRes;
	
	double fPEmin;
	double fMinTrackLength;
	double fTDiffMax;

	double fFlashScaleFactor;
	double fFlashTPCOffset;

	//functions to be used throughout module
	bool   TrackExitsBottom   (const std::vector<TVector3>& sorted_trk);
	bool   TrackExitsFront    (const std::vector<TVector3>& sorted_trk);
	bool   TrackExitsBack     (const std::vector<TVector3>& sorted_trk);
	bool   TrackExitsAnode    (const std::vector<TVector3>& sorted_trk, const int driftDir);
	bool   TrackExitsSide     (const std::vector<TVector3>& sorted_trk);
  
	void   SortTrackPoints      (const recob::Track& track, std::vector<TVector3>& sorted_trk);
	void   SplitTrack(const recob::Track& track, std::vector<TVector3>& sorted_trk);
	
	double GetEnteringTimeCoord (const std::vector<TVector3>& sorted_trk);
	double GetExitingTimeCoord  (const std::vector<TVector3>& sorted_trk);
	
	size_t FlashMatch(const double reco_time, std::vector<double>);
	
	double MatchTracks(std::vector<TVector3>& sorted_trk, std::vector<TLorentzVector> mcpart);
  	std::vector<std::vector< TLorentzVector>> BuildMCParticleList(const art::Handle<std::vector<simb::MCParticle>>& mcpart_h, const double& fTPCResolution, const double& width);
  	
	TTree *track_tree;
	// Track parameters
	double 	_rc_time;
	double 	_length;
	double 	_rc_xs, _rc_xe, _rc_xs_corr, _rc_xe_corr;
	double 	_rc_ys, _rc_ye;
	double 	_rc_zs, _rc_ze;
	// Track parameters for cathode crossing anode piercing tracks
	double	_anode_rc_time;
	double	_cathode_rc_time;
	double	dt_anode_cathode;
	// Flash parameters
	double 	_matched_flash_pe;	
	double 	_matched_flash_time;
	double 	_matched_flash_time_width;
	double 	_corrected_matched_flash_time;
	double	_matched_flash_centre_y;
	double	_matched_flash_centre_z;
	double	_matched_flash_width_y;
	double	_matched_flash_width_z;
	// Reco results
	double 	_dt_flash_reco;
	// Track info
	double 	_driftDir;
	bool 	TPC_edge;
	bool 	anode_piercing_track_candidate;
	bool 	_cathode_crossing_track;
	int 	sister_track;
	// MC info
	double 	mc_time;
	double 	mc_particle_xs;
	double 	mc_particle_ys;
	double 	mc_particle_zs;
	double 	mc_particle_ts;
	double 	mc_particle_xe;
	double 	mc_particle_ye;
	double 	mc_particle_ze;
	double 	mc_particle_te;
	double 	_mc_matched_flash_time;
	double 	_dt_mc_reco;
	double 	_dt_mc_flash;
	//double	_purity;
	bool 	_anode_entering;
	bool	_anode_exiting;
	bool	_true_anode_piercer;
	// Tree for flash info
	TTree 	*_flash_tree;
	double 	_flash_reco_time_diff;
	double 	_corrected_flash_reco_time_diff;
	double 	_flash_time;
	double 	_flash_time_width;
	double 	_corrected_flash_time;
	double 	_flash_pe;
	double	_flash_centre_y;
	double	_flash_centre_z;
	double	_flash_width_y;
	double	_flash_width_z;
	// Tree for event info
	TTree 	*_evTree;
	int 	run;
	int	event;
	int 	total_particle_ctr;
	int 	ev_ctr;
	
};

T0RecoSCECalibrations::T0RecoSCECalibrations(fhicl::ParameterSet const & p)
	:
	EDAnalyzer(p)
{

	fTrackProducer     	= p.get<std::string>	("TrackProducer"    	);
	fHitProducer       	= p.get<std::string>	("HitProducer"      	);
	fFlashProducer     	= p.get<std::string>	("FlashProducer"    	);
	fTriggerProducer	= p.get<std::string>	("TriggerProducer"  	);
	fPFPProducer		= p.get<std::string>	("PFPProducer"  	);

	fUseMC             = p.get<bool>	("UseMC"            	);

	fData              = p.get<bool>   	("Data"             	);

	fTPCResolution     = p.get<double>	("Resolution"       	);
	fTimeRes           = p.get<double> 	("TimeRes"         	);

	fPEmin             = p.get<double> 	("PEmin"           	);
	fMinTrackLength	   = p.get<double>	("MinTrackLength"    	);
	fTDiffMax     	   = p.get<double> 	("TDiffMax"         	);

	fCathode           = p.get<bool>  	("CathodeCrossers"  	);
	fAnode    	   = p.get<bool>  	("AnodePiercers"    	);

	debug             = p.get<bool>  	("debug"            	);

	fAllFlash     	   = p.get<bool>  	("OutputAllFlashes" 	);

	fFlashScaleFactor  = p.get<double>	("FlashScaleFactor" 	);
	fFlashTPCOffset	   = p.get<double>	("FlashTPCOffset"	    	);

	// get boundaries based on detector bounds
	auto const* geom = lar::providerFrom<geo::Geometry>();
  
	_TOP = fTPCResolution;
	_BOTTOM = fTPCResolution;
	_FRONT = fTPCResolution;
	_BACK = fTPCResolution;

	for (geo::TPCID const& tID: geom->IterateTPCIDs()) {
		geo::TPCGeo const& TPC = geom->TPC(tID);
   
		if(TPC.DriftDistance() < 25.0) continue;
   
		double origin[3] = {0.};
		double center[3] = {0.};
		TPC.LocalToWorld(origin, center);
   
		double top = center[1] + TPC.HalfHeight() - fTPCResolution;
		double bottom = center[1] - TPC.HalfHeight() + fTPCResolution;
		double front = center[2] - TPC.HalfLength() + fTPCResolution;
		double back = center[2] + TPC.HalfLength() - fTPCResolution;
   
		if (top > _TOP) _TOP = top;
		if (bottom < _BOTTOM) _BOTTOM = bottom;
		if (front < _FRONT) _FRONT = front;
		if (back  > _BACK) _BACK = back;  
   
		_det_width = TPC.DriftDistance();
	}
  
	// Use '_detp' to find 'efield' and 'temp'
	auto const* _detp = lar::providerFrom<detinfo::DetectorPropertiesService>();
	double efield = _detp -> Efield();
	double temp   = _detp -> Temperature();
	// Determine the drift velocity from 'efield' and 'temp'
	fDriftVelocity = _detp -> DriftVelocity(efield,temp);

	
	
}  
  
void T0RecoSCECalibrations::beginJob(){

	art::ServiceHandle<art::TFileService> tfs;
	track_tree = tfs->make<TTree>("track_tree","SCE calibrations variables");
	//Track parameters
	track_tree->Branch("_rc_time",&_rc_time,"rc_time/D");
	track_tree->Branch("_length", &_length, "length/D");
	track_tree->Branch("_rc_xs",&_rc_xs,"rc_xs/D");
	track_tree->Branch("_rc_xs_corr",&_rc_xs_corr,"rc_xs/D");
	track_tree->Branch("_rc_ys",&_rc_ys,"rc_ys/D");
	track_tree->Branch("_rc_zs",&_rc_zs,"rc_zs/D");
	track_tree->Branch("_rc_xe",&_rc_xe,"rc_xe/D");
	track_tree->Branch("_rc_xe_corr",&_rc_xe_corr,"rc_xe_corr/D");
	track_tree->Branch("_rc_ye",&_rc_ye,"rc_ye/D");
	track_tree->Branch("_rc_ze",&_rc_ze,"rc_ze/D");

	if(fCathode&&fAnode) {
	track_tree->Branch("_cathode_rc_time",&_cathode_rc_time,"cathode_rc_time/D");
	track_tree->Branch("_anode_rc_time",&_anode_rc_time,"anode_rc_time/D");
	track_tree->Branch("dt_anode_cathode",&dt_anode_cathode,"dt_anode_cathode/D");
	}
	
	//Flash parameters
	track_tree->Branch("_matched_flash_time",&_matched_flash_time,"matched_flash_time/D");
	track_tree->Branch("_matched_flash_time_width",&_matched_flash_time_width,"matched_flash_time_width/D");
	track_tree->Branch("_corrected_matched_flash_time",&_corrected_matched_flash_time,"corrected_matched_flash_time/D");
	track_tree->Branch("_matched_flash_pe",&_matched_flash_pe,"matched_flash_pe/D");
	track_tree->Branch("_matched_flash_centre_y",&_matched_flash_centre_y,"matched_flash_centre_y/D");
	track_tree->Branch("_matched_flash_centre_z",&_matched_flash_centre_z,"matched_flash_centre_z/D");
	track_tree->Branch("_matched_flash_width_y",&_matched_flash_width_y,"matched_flash_width_y/D");
	track_tree->Branch("_matched_flash_width_z",&_matched_flash_width_z,"matched_flash_width_z/D");

	//Flash -> track time difference
	track_tree->Branch("_dt_flash_reco",&_dt_flash_reco,"dt_flash_reco/D");

	//track_tree->Branch("TPC_edge",&TPC_edge,"TPC_edge/B");
	
	// Branches for MC variables
	if(fUseMC) {
	track_tree->Branch("mc_time",&mc_time,"mc_time/D");
	track_tree->Branch("mc_particle_xs",&mc_particle_xs,"mc_particle_xs/D");
	track_tree->Branch("mc_particle_ys",&mc_particle_ys,"mc_particle_ys/D");
	track_tree->Branch("mc_particle_zs",&mc_particle_zs,"mc_particle_zs/D");
	track_tree->Branch("mc_particle_xe",&mc_particle_xe,"mc_particle_xe/D");
	track_tree->Branch("mc_particle_ye",&mc_particle_ye,"mc_particle_ye/D");
	track_tree->Branch("mc_particle_ze",&mc_particle_ze,"mc_particle_ze/D");

	track_tree->Branch("_dt_mc_reco",&_dt_mc_reco,"dt_mc_reco/D");
	//track_tree->Branch("_purity",&_purity,"purity/D");
	//track_tree->Branch("_anode_entering",&_anode_entering,"anode_entering/B");
	//track_tree->Branch("_anode_exiting",&_anode_exiting,"anode_exiting/B");
	track_tree->Branch("_true_anode_piercer",&_true_anode_piercer,"true_anode_piercer/B");
	}

	// Information on whether track crosses anode or cathode
	track_tree->Branch("anode_piercing_track_candidate",&anode_piercing_track_candidate,"anode_piercing_track_candidate/I"  );
	track_tree->Branch("_cathode_crossing_track",&_cathode_crossing_track,"cathode_crossing_track/I");
	
	//track_tree->Branch("sister_track",&sister_track,"sister_track/I");


	// Flash Tree
	if (fAllFlash) {
	_flash_tree = tfs->make<TTree>("_flash_tree","Flash properties and reco time differences");
	_flash_tree->Branch("_flash_time",&_flash_time,"flash_time/D");
	_flash_tree->Branch("_flash_time_width",&_flash_time_width,"flash_time_width/D");
	_flash_tree->Branch("_corrected_flash_time",&_corrected_flash_time,"corrected_flash_time/D");
	//_flash_tree->Branch("_flash_reco_time_diff",&_flash_reco_time_diff,"flash_reco_time_diff/D");
	_flash_tree->Branch("_corrected_flash_reco_time_diff",&_corrected_flash_reco_time_diff,"corrected_flash_reco_time_diff/D");
	_flash_tree->Branch("_flash_pe",&_flash_pe,"flash_pe/D");
	_flash_tree->Branch("_flash_centre_y",&_flash_centre_y,"flash_centre_y/D");
	_flash_tree->Branch("_flash_centre_z",&_flash_centre_z,"flash_centre_z/D");
	_flash_tree->Branch("_flash_width_y",&_flash_width_y,"flash_width_y/D");
	_flash_tree->Branch("_flash_width_z",&_flash_width_z,"flash_width_z/D");

	}

	// Event Tree
	_evTree = tfs->make<TTree>("_evTree","Event information");
	_evTree->Branch("total_particle_ctr",&total_particle_ctr,"total_particle_ctr/I");
	_evTree->Branch("ev_ctr",&ev_ctr,"ev_ctr/I");
	_evTree->Branch("run",&run,"run/I");
	_evTree->Branch("event",&event,"event/I");
	ev_ctr = 0;
	total_particle_ctr = 0;
	
}
  
void T0RecoSCECalibrations::analyze(art::Event const & e){

	event = e.event();
	run = e.run();
 	int track_number = 0;
	ev_ctr++;

	double TPC_trigger_offset = 0.0;

	std::vector<std::vector<TLorentzVector>> mcpart_list;
	
	std::cout << "Event number: " << ev_ctr << std::endl;
	if(debug) std::cout << "Set event number: " << event << "\ntop: " << _TOP << "\nbottom: " << _BOTTOM 
	<< "\nfront: " << _FRONT << "\nback: " << _BACK << std::endl;  
  
	_flash_times.clear();
	_flash_id_v.clear();
	flash_h.clear();
	
	// load Flash
	if (debug) std::cout << "Loading flash from producer " << fFlashProducer << std::endl;

	if(fAnode||fAllFlash){
	e.getByLabel(fFlashProducer,flash_h);

	// make sure flashes look good
	if(!flash_h.isValid()) {
		std::cerr<<"\033[93m[ERROR]\033[00m ... could not locate Flash!"<<std::endl;
    	throw std::exception();
  	}
  	}
  	
  	if(debug&&fData) std::cout << "Loading trigger time from producer " << fTriggerProducer << std::endl;
  	art::Handle<std::vector<recob::OpFlash> > trigger_h;
	double trigger_time = 0;

  	if(fData){
  		e.getByLabel(fTriggerProducer, trigger_h);
  		trigger_time = trigger_h->at(0).Time();
  	}

	// load PFParticles

	auto reco_particles_h = e.getValidHandle<std::vector<recob::PFParticle>>(fPFPProducer);
	
	if(!reco_particles_h.isValid()) {
	std::cerr<<"\033[93m[ERROR]\033[00m ... could not locate PFParticles!"<<std::endl;
	throw std::exception(); }

	// Utilities for PFParticles and tracks
	protoana::ProtoDUNEPFParticleUtils pfpUtil;
	protoana::ProtoDUNETrackUtils trackUtil;
	protoana::ProtoDUNETruthUtils truthUtil;

	/* OLD - NECESSARY IF LOOKING BACK AT PMTRACK THOUGH
  	// load tracks previously created for which T0 reconstruction should occur

  	if (debug) std::cout << "Loading track from producer " << fTrackProducer << std::endl;
  	art::Handle<std::vector<recob::Track> > track_h;
  	e.getByLabel(fTrackProducer,track_h);

  	// make sure tracks look good
  	if(!track_h_pmtrack.isValid()) {
   		std::cerr<<"\033[93m[ERROR]\033[00m ... could not locate Track!"<<std::endl;
    	throw std::exception();	}

  	std::vector<art::Ptr<recob::Track> > TrkVec;
  	art::fill_ptr_vector(TrkVec, track_h);

  	// grab 2d hits associated with tracks - 
  	art::FindMany<recob::Hit> trk_hit_assn_v(track_h, e, fHitProducer);
	*/

	// load MCParticles
	
	//auto mclist_h = e.getValidHandle<std::vector<simb::MCTruth> >("generator");
  	art::Handle<std::vector<simb::MCParticle> > mcpart_h;
  	e.getByLabel("largeant",mcpart_h);

  	// if we should use MCParticle
  	if (fUseMC){
		// make sure particles exist
		if(!mcpart_h.isValid()) {
			std::cerr<<"\033[93m[ERROR]\033[00m ... could not locate MCParticle!"<<std::endl;
			throw std::exception(); }

		// NOT NEEDED WITH PANDORA RECONSTRUCTION
		/*mcpart_list = BuildMCParticleList(mcpart_h,fTPCResolution,_det_width);
		// Get all the MC particle ids.
		std::set<int> particleIDs;
	  	art::FindManyP<simb::MCParticle> geantAssns(mclist_h,e,"largeant");
	  	for ( size_t i = 0; i < geantAssns.size(); i++) {
	      		auto parts = geantAssns.at(i);
	      		for (auto part = parts.begin(); part != parts.end(); part++) {
	       			particleIDs.emplace((*part)->TrackId()); }
			}
		*/
   	}
	// ^ if use MCParticle

	// Get trigger to TPC Offset
	auto const* detclock = lar::providerFrom<detinfo::DetectorClocksService>();
	TPC_trigger_offset = detclock->TriggerOffsetTPC();
	if(debug) std::cout << "TPC time offset from trigger: " << TPC_trigger_offset << " us" << std::endl;

	// Prepare a vector of optical flash times, if flash above some PE cut value

	if(fAnode||fAllFlash){
  		size_t flash_ctr = 0;
  		for (auto const& flash : *flash_h){
    			if (flash.TotalPE() > fPEmin){
      				_flash_times.push_back(flash.Time() - trigger_time);
      				_flash_id_v.push_back(flash_ctr);
      				/*if (debug) std::cout << "\t Flash: " << flash_ctr << " has time : "
				<< flash.Time() - trigger_time << ", PE : " << flash.TotalPE() << std::endl;*/
   				}
    			flash_ctr++;
  		}// for all flashes

  		if(!fAnode) {auto const& output_flashes = FlashMatch(0.0,_flash_times);
			if (debug) std::cout << "Output all flashes - closest flash to trigger time has time: "
			<< output_flashes << std::endl; }

   		if(debug) std::cout << "Selected a total of " << _flash_times.size() << " OpFlashes" << std::endl;
	}
  
	// LOOP THROUGH RECONSTRUCTED PFPARTICLES

	size_t ev_particle_ctr = 0;

	for(unsigned int p = 0; p < reco_particles_h->size(); ++p){

		ev_particle_ctr ++;
		total_particle_ctr ++;

		recob::PFParticle particle = (*reco_particles_h)[p];
		const recob::Track* track = pfpUtil.GetPFParticleTrack(particle,e,fPFPProducer,fTrackProducer);
		if(track == 0x0) { 
			if(debug) std::cout << "\tPFParticle " << ev_particle_ctr << " is not track like" << std::endl;
			continue; } 

	//for (auto& track : TrkVec){ // OLD, FROM PMTRACK

		if (debug) std::cout << "\tLooping through reco PFParticle " << ev_particle_ctr << std::endl;  

		const std::vector<const recob::Hit*>& hit_v = trackUtil.GetRecoTrackHits(*track,e,fTrackProducer);

		_rc_time = 4999.;
		_anode_rc_time = 3999.;
		_cathode_rc_time = 5999.;

		_length = 0.;
		_rc_xs = 499.;
		_rc_xe = -499.; 
		_rc_xs_corr = 499.;
		_rc_xe_corr = -499.;
		_rc_ys = -100.;
		_rc_ye = -100.; 
		_rc_zs = -100.; 
		_rc_ze = -100.;

		_matched_flash_time = -4999.;
		_corrected_matched_flash_time = -4999.;
		_matched_flash_time_width = -1.;
		_matched_flash_pe = 0.;
		_matched_flash_centre_y = -100.;
		_matched_flash_centre_z = -100.;
		_matched_flash_width_y = -100.;
		_matched_flash_width_z = -100.;

		_driftDir = 0;

		mc_time = 9999.;
		//_purity = 0.;

		anode_piercing_track_candidate = false;
		_cathode_crossing_track = false;
		sister_track = 0;
  
 		// get sorted points for the track object [assuming downwards going]
    		std::vector<TVector3> sorted_trk;
	    	SortTrackPoints(*track,sorted_trk);

    		auto const &track_start = sorted_trk.at(0);
   		auto const &track_end = sorted_trk.at(sorted_trk.size() - 1);

	    	if(debug) std::cout << "\t\tTrack goes from (" << track_start.X() << ", " 
		<< track_start.Y() << ", " << track_start.Z() << ") --> (" << track_end.X() << ", " 
		<< track_end.Y() << ", " << track_end.Z() << ")" << std::endl;

	      	if((fabs(track_start.X()) > 360 || track_start.Y() < 0 || track_start.Y() > 600 ||
		track_start.Z() < 0 || track_start.Z() > 700) && (fabs(track_end.X()) > 360 || 
		track_end.Y() < 0 || track_end.Y() > 600 || track_end.Z() < 0 || track_end.Z() > 700)) {
      			if(debug) std::cout << "\t\t\tParticle track does not enter TPC. Skipping. " << std::endl;
      			continue;
	      	}

	      	if(sqrt(pow(track_start.X() - track_end.X(),2.0) + pow(track_start.Y() - track_end.Y(),2.0)
		+ pow(track_start.Z() - track_end.Z(),2.0)) < fMinTrackLength )	{
      			if(debug) std::cout << "\t\t\tParticle track too short. Skipping." << std::endl;
      			continue;
	      	}

     		// Determine if the track crosses the cathode 
    		bool cross_cathode = false;
		auto const* geom = lar::providerFrom<geo::Geometry>();   
    		auto const* hit = hit_v.at(0);
	    	const geo::WireID wireID = hit->WireID();
		const auto TPCGeoObject = geom->TPC(wireID.TPC,wireID.Cryostat);
		short int driftDir = TPCGeoObject.DetectDriftDirection();

	    	for (size_t ii = 1; ii < hit_v.size(); ii++) {
    			const geo::WireID wireID2 = hit_v.at(ii)->WireID();
			const auto TPCGeoObject2 = geom->TPC(wireID2.TPC,wireID2.Cryostat);
			short int driftDir_tmp = TPCGeoObject2.DetectDriftDirection(); 
		
			if(driftDir_tmp + driftDir == 0){
				cross_cathode = true;
				ii = hit_v.size();
			}
		}


		// if we should use MC info -> continue w/ MC validation
      		if (fUseMC){

			const simb::MCParticle* mc_particle = truthUtil.GetMCParticleFromRecoTrack(*track,e,fTrackProducer);

			if(mc_particle==0x0) { 
				if(debug) std::cout << "\t\t\tNo MC particle matched to PFParticle " << ev_particle_ctr << std::endl;
				continue; }

			mc_particle_xs = mc_particle->Position(0).X();
			mc_particle_ys = mc_particle->Position(0).Y();
			mc_particle_zs = mc_particle->Position(0).Z();
			mc_particle_ts = mc_particle->T(0)/1000;

			int last_mc_point = mc_particle->NumberTrajectoryPoints()-1;
			mc_particle_xe = mc_particle->Position(last_mc_point).X();
			mc_particle_ye = mc_particle->Position(last_mc_point).Y();
			mc_particle_ze = mc_particle->Position(last_mc_point).Z();
			mc_particle_te = mc_particle->T(last_mc_point)/1000;

			mc_time = mc_particle_ts;
			if(fabs(mc_particle_te - mc_particle_ts)>1) std::cout << "\t\t\tMC Particle end time: "
			 << mc_particle_te << " us significantly different from start time: " << 
			mc_particle_ts << " us" << std::endl;
			}

		// -------------------------------------------------------------------------------
		// CATHODE CROSSERS
		if(fCathode){

			if(!cross_cathode) { 
				std::cout << "\t\tTrack does not cross cathode."<< std::endl;
				continue; }

			_cathode_crossing_track = true;

			//GET T0 FROM PFPARTICLE
			auto t0_v = pfpUtil.GetPFParticleT0(particle,e,fPFPProducer);
			if(t0_v.size() == 0) continue; 
			auto t0 = t0_v.at(0);
			_cathode_rc_time = t0.Time()/1000;

			if (debug) std::cout << "\t\tTrack crossers cathode - PFParticle has t0: " 
			<< _cathode_rc_time << " against MC particle t0: " << mc_time << std::endl;

			// Old pmtrack t0 method, doesn't work
			/*art::FindMany<anab::T0> trk_t0_assn_v(track_h, e, "pmtrack");
			const std::vector<const anab::T0*>& T0_old_v = trk_t0_assn_v.at(trk_ctr);
			auto t0_old = T0_old_v.at(0);
			if (debug) std::cout << "Track: " << trk_ctr << " has pmtrack t0: "
			<< t0_old->Time() << std::endl;*/
			
			_rc_time = _cathode_rc_time;
			_dt_mc_reco = mc_time - _rc_time;

			std::vector<TVector3> split_trk = sorted_trk;

    			SplitTrack(*track,split_trk);
    			std::vector<TVector3> top_trk = {split_trk.at(0), split_trk.at(1)};
	    		std::vector<TVector3> bottom_trk = {split_trk.at(2), split_trk.at(3)};
    	
		    	if(debug) std::cout << "\t\tCathode-crossing point: (" << top_trk.at(1).X() << 
			", " << top_trk.at(1).Y() << ", " << top_trk.at(1).Z() << ") --> (" << 
			bottom_trk.at(0).X() << ", " << bottom_trk.at(0).Y() << ", " << 
			bottom_trk.at(0).Z() << ")" << std::endl;
    	
    			// Top Track!
		    	//if(debug) std::cout << "\tTop track" << std::endl;
    	
    			sister_track = track_number + 1;
		    	auto const &top_track_start = top_trk.at(0);
	    		auto const &top_track_end = top_trk.at(1);
		
			_rc_xs = top_track_start.X();
			_rc_xs_corr = _rc_xs;
    			_rc_ys = top_track_start.Y();
    			_rc_zs = top_track_start.Z();
    			_rc_xe = top_track_end.X();
    			_rc_xe_corr = _rc_xe;
    			_rc_ye = top_track_end.Y();
    			_rc_ze = top_track_end.Z();
    	
			_length = sqrt(pow(_rc_xs - _rc_xe,2.0) + pow(_rc_ys - _rc_ye,2.0) + 
			pow(_rc_zs - _rc_ze,2.0));

			if(_rc_xs<0.0) _driftDir = -1;
			else _driftDir = 1;
		
			track_tree->Fill();
			track_number++;
		
			// Bottom Track
			//if(debug) std::cout << "\tBottom track" << std::endl;
			sister_track = track_number - 1;
		
			auto const &bottom_track_start = bottom_trk.at(0);
		    	auto const &bottom_track_end = bottom_trk.at(1);
		
			_rc_xs = bottom_track_start.X();
			_rc_xs_corr = _rc_xs;
    			_rc_ys = bottom_track_start.Y();
    			_rc_zs = bottom_track_start.Z();
    			_rc_xe = bottom_track_end.X();
    			_rc_xe_corr = _rc_xe;
    			_rc_ye = bottom_track_end.Y();
    			_rc_ze = bottom_track_end.Z();
    	
			_length = sqrt(pow(_rc_xs - _rc_xe,2.0) + pow(_rc_ys - _rc_ye,2.0) + pow(_rc_zs - _rc_ze,2.0));
			if(_rc_xs<0.0) _driftDir = -1;
			else _driftDir = 1;
		
			track_tree->Fill();
			track_number++;
		}
		    
		
		// ------------------------------------------------------------------------------------
		// ANODE PIERCERS 
		if(fAnode){	
			// if(debug) std::cout << "\t\tThis track starts in TPC " << wireID.TPC <<
			//" which has a drift direction of " << driftDir << std::endl; 
			_driftDir = driftDir;
	
			// create root trees variables
    
   			_rc_xs = track_start.X();
		  	_rc_ys = track_start.Y();
		  	_rc_zs = track_start.Z();
	    		_rc_xe = track_end.X();
	    		_rc_ye = track_end.Y();
    			_rc_ze = track_end.Z();
    			_length = track->Length();

			anode_piercing_track_candidate = false;

    			// 1st category: tracks which may enter an APA
    			if (_rc_ys < _TOP && _rc_zs > _FRONT && _rc_zs < _BACK) {

      				// reconstruct track T0 w.r.t. trigger time
				if( ( _rc_xs < _rc_xe && driftDir<0 ) || 
				( _rc_xs > _rc_xe && driftDir>0 ) ) {
					_anode_rc_time = (_det_width - driftDir * _rc_xs) / fDriftVelocity;
					if(debug) std::cout << "\t\tTrack enters anode. Reco t0: " 
					<< _anode_rc_time << " from anode entering position: " << 
					_rc_xs << std::endl;
					anode_piercing_track_candidate = true;
      				}

    			}

    			// When track may exit an APA
    			if (_rc_ye > _BOTTOM && _rc_ze > _FRONT && _rc_ze < _BACK) {

      				// reconstruct track T0 w.r.t. trigger time	
				if( ( _rc_xe < _rc_xs && driftDir<0 ) || 
				( _rc_xe > _rc_xs && driftDir>0 ) ) {
					_anode_rc_time = (_det_width - driftDir * _rc_xe) / fDriftVelocity;
					if(debug) std::cout << "\t\tTrack exits anode. Reco t0:" 
					<< _anode_rc_time << " from anode exiting position: " << 
					_rc_xe << std::endl;
					anode_piercing_track_candidate = true;
      				}

  			}// if the track exits the side
	
			if(!anode_piercing_track_candidate) {
				if(debug) std::cout << "\t\tTrack does not pierce anode." << std::endl;
				continue; }
    
    			_rc_xs_corr = _rc_xs + driftDir*_anode_rc_time*fDriftVelocity;
    			_rc_xe_corr = _rc_xe + driftDir*_anode_rc_time*fDriftVelocity;
    
			// Determine if track hits edge of readout window
    			TPC_edge = false;
			//Turn back on if late/early tracks get much worse
    			/*for (auto& hits : hit_v) {
    				auto peakHit = hits->PeakTime();
    				//if(debug) std::cout << "\t\tHit time of track " << trk_ctr << ": " << 
				//peakHit << " in TPC " << hits->WireID().TPC << " plane " << 
				//hits->WireID().Plane << " and wire " << hits->WireID().Wire << std::endl;
    				if( peakHit > (6000.0 - 50.0) || peakHit < 50.0 ){
    		 			TPC_edge = true;
    		 			//if(debug) std::cout << "\t\tHit time out of range: " << peakHit << std::endl;
    				}
    			} */
	
			if(TPC_edge) {
				if(debug) std::cout << "\t\tTrack hits edge of readout window. Skipping." << std::endl;
				continue; }

    			// FLASH MATCHING
    			auto const& flash_match_result = FlashMatch((_anode_rc_time + TPC_trigger_offset),_flash_times);
    			const art::Ptr<recob::OpFlash> flash_ptr(flash_h, flash_match_result);

    			_matched_flash_time = flash_ptr->Time() - trigger_time;
			_corrected_matched_flash_time = fFlashScaleFactor*_matched_flash_time + fFlashTPCOffset;
			_matched_flash_time_width = flash_ptr->TimeWidth() - trigger_time;

	    		_dt_flash_reco = _corrected_matched_flash_time - (_anode_rc_time + TPC_trigger_offset);
	    
	    		_matched_flash_pe = flash_ptr->TotalPE();
			_matched_flash_centre_y = flash_ptr->YCenter();
			_matched_flash_centre_z = flash_ptr->ZCenter();
			_matched_flash_width_y = flash_ptr->YWidth();
			_matched_flash_width_z = flash_ptr->ZWidth();
    
   			if(debug) std::cout << "\t\t Matched to flash w/ index " << flash_match_result << " w/ PE " 
    			<< _matched_flash_pe << ", corrected time " << _corrected_matched_flash_time << 
			" vs corrected reco time " << _anode_rc_time + TPC_trigger_offset << std::endl;

			// if we should use MC info -> continue w/ MC validation
      			if (fUseMC){
				if(fabs(mc_particle_xs) > 358.5 && mc_particle_ys > 0.0 && 
				mc_particle_ys < 610.0 && mc_particle_zs > 0.0 && mc_particle_zs < 700.0)
				 _anode_entering = true;

				if(fabs(mc_particle_xe) > 358.5 && mc_particle_ye > 0.0 && 
				mc_particle_ye < 610.0 && mc_particle_ze > 0.0 && mc_particle_ze < 700.0)
				_anode_exiting = true;

				if(_anode_exiting || _anode_entering) _true_anode_piercer = true;
	
		  		if(debug) std::cout << "\t\tMC Particle matched to track has t0: " << 
				mc_time << " us against reconstructed t0: " << _anode_rc_time << " us" 
				<< std::endl;

				if (!cross_cathode) _dt_mc_reco = mc_time - _anode_rc_time;

				// OLD METHOD - loop through MCParticles to find the one that matches.
				/*
				double _displacement = 1.0;
	  
				for (unsigned int j=0; j < mcpart_list.size(); j++){

	  				std::vector<TLorentzVector> mcpart = mcpart_list.at(j);
	  
	  				// try matching to MC
	  				double _tmp_disp = MatchTracks(sorted_trk, mcpart);
	  				if ((_tmp_disp > _displacement)||isnan(_tmp_disp)) continue;

					_anode_entering = false;
					_anode_exiting = false;
					_true_anode_piercer = false;

	  				if(debug) std::cout <<"\t\tMCParticle starts at: (" << mcpart.at(0).X() << ", " 
					<< mcpart.at(0).Y() << ", " << mcpart.at(0).Z() << ") and goes to (" << mcpart.at(1).X() <<
					", " << mcpart.at(1).Y() << ", " << mcpart.at(1).Z() << ")" << std::endl;
	  
	  				// matched -> get MCTrack time and reconstructed track reconstructed T0
	  				_displacement = _tmp_disp;
	  				mc_time = mcpart.at(0).T() / 1000.;
	  				_dt_mc_reco = mc_time - _rc_time;

					if(fabs(mcpart.at(0).X()) > 358.5 && fabs(mcpart.at(0).X()) < 359.5 && 
					mcpart.at(0).Y() > 0.0 && mcpart.at(0).Y() < 610.0 && mcpart.at(0).Z() > 0.0
					 && mcpart.at(0).Z() < 700.0) 
					_anode_entering = true;

					if(fabs(mcpart.at(1).X()) > 358.5 && fabs(mcpart.at(1).X()) < 359.5 && 
					mcpart.at(1).Y() > 0.0 && mcpart.at(1).Y() < 610.0 && mcpart.at(1).Z() > 0.0
					 && mcpart.at(1).Z() < 700.0) 
					_anode_exiting = true;

					if(_anode_exiting || _anode_entering) _true_anode_piercer = true;
				
	  				if(debug) std::cout << "\t\tParticle number: " << j << " with sigma comparison value of " 
	  				<< _displacement << "\n\t\tTrack matched to MC value with t0 of " << mc_time << 
	  				" and reconstructed time of " << _rc_time << std::endl;
				
	  			} // ^ for all MCParticles
      				*/

			} // ^ if we should use MCParticles

			if (!cross_cathode) _rc_time = _anode_rc_time;

			if(_anode_rc_time<3000&&_cathode_rc_time<3000) 
			dt_anode_cathode = _anode_rc_time - _cathode_rc_time;

      			if(abs(_dt_flash_reco) < fTDiffMax) track_tree->Fill();
      			track_number++;
	
		}
    
    	}
    
	_evTree->Fill();
}

// NOT NEEDED WITH PANDORA RECONSTRUCTION
std::vector<std::vector< TLorentzVector >> T0RecoSCECalibrations::BuildMCParticleList(const art::Handle<std::vector<simb::MCParticle> >& mcpart_h,const double& fTPCResolution, const double& width){

	std::vector<std::vector< TLorentzVector>> mcVec;

	for (size_t j=0; j < mcpart_h->size(); j++){
			
		auto const& mcpart = mcpart_h->at(j);
		
		double x0 = mcpart.Position(0).X();
		double y0 = mcpart.Position(0).Y();
		double z0 = mcpart.Position(0).Z();
		double t0 = mcpart.T(0);
		double x1 = mcpart.Position(mcpart.NumberTrajectoryPoints()-1).X();
		double y1 = mcpart.Position(mcpart.NumberTrajectoryPoints()-1).Y();
		double z1 = mcpart.Position(mcpart.NumberTrajectoryPoints()-1).Z();
		double t1 = mcpart.T(mcpart.NumberTrajectoryPoints()-1);
		
		//double xs = x0, ys = y0, zs = z0, ts = t0;
		//double xe = x1, ye = y1, ze = z1, te = t1;
		
		bool top_ok = false, bot_ok = false;
		//std::cout << mcpart.NumberTrajectoryPoints() << std::endl;
		if(mcpart.NumberTrajectoryPoints()<2900){
		for(size_t k = 0; k<mcpart.NumberTrajectoryPoints(); k++){
			if ((x0 > width) || (x0 < -width) || (y0 > _TOP + fTPCResolution) || (y0 < _BOTTOM - fTPCResolution) || (z0 < _FRONT - fTPCResolution) || (z0 > _BACK + fTPCResolution) ){
				x0 = mcpart.Position(k+1).X();
				y0 = mcpart.Position(k+1).Y();
				z0 = mcpart.Position(k+1).Z();
				t0 = mcpart.T(k+1);
			} else top_ok = true;

			if ((x1 > width) || (x1 < -width) || (y1 > _TOP + fTPCResolution) || (y1 < _BOTTOM - fTPCResolution) || (z1 < _FRONT - fTPCResolution) || (z1 > _BACK + fTPCResolution) ){
				x1 = mcpart.Position(mcpart.NumberTrajectoryPoints()-2-k).X();
				y1 = mcpart.Position(mcpart.NumberTrajectoryPoints()-2-k).Y();
				z1 = mcpart.Position(mcpart.NumberTrajectoryPoints()-2-k).Z();
				t1 = mcpart.T(mcpart.NumberTrajectoryPoints()-2-k);
			} else bot_ok = true;

			if(top_ok&&bot_ok) k = mcpart.NumberTrajectoryPoints();
		}
		}
			
		double xs = x0, ys = y0, zs = z0, ts = t0;
		double xe = x1, ye = y1, ze = z1, te = t1;
		
		TLorentzVector mc_top(TVector3(xs,ys,zs),ts);
		TLorentzVector mc_bot(TVector3(xe,ye,ze),te);
		//if (!top_ok||!bot_ok) continue;
		
		if (ys >  ye) mcVec.push_back({mc_top, mc_bot});
		else mcVec.push_back({mc_bot, mc_top});
		//if(debug) std::cout << " MCParticle: (" << x0 << ", " << y0 << ", " << z0 << ", " << t0/1000. << ") --> (" << xs << ", " << ys << ", " << zs << ", " << ts/1000.0 << ") --> (" << xe << ", " << ye << ", " << ze << ", " << te/1000.0 << ") --> (" << x1 << ", " << y1 << ", " << z1 << ", " << t1/1000.0 << ")" << std::endl;
		
	}
		return mcVec;	

}

void   T0RecoSCECalibrations::SortTrackPoints(const recob::Track& track, std::vector<TVector3>& sorted_trk)
{
	sorted_trk.clear();
		
	TVector3 track_start, track_end;	
	double start_y = _BOTTOM - 2.0*fTPCResolution;
	double end_y = _TOP + 2.0*fTPCResolution;
	
	for (size_t ii = 0; ii < track.NumberTrajectoryPoints(); ii++){
		auto const& trk_loc = track.LocationAtPoint(ii);
		
		if ((trk_loc.X() < -998.)||(trk_loc.Y() < -998.)||(trk_loc.Z() < -998)) continue;
		
		if (trk_loc.Y() < end_y){
			end_y = trk_loc.Y();
			track_end = {trk_loc.X(), trk_loc.Y(), trk_loc.Z()};
		}
		if (trk_loc.Y() > start_y){
			start_y = trk_loc.Y();
			track_start = {trk_loc.X(), trk_loc.Y(), trk_loc.Z()};
		}
	}
	
	sorted_trk.push_back(track_start);
	sorted_trk.push_back(track_end);
	
	/*  THIS METHOD ASSUMES THE TRACK IS SORTED AT ALL!!
  	// vector to store 3D coordinates of
  	// ordered track
  	sorted_trk.clear();

  	// take the reconstructed 3D track
  	// and assuming it is downwards
  	// going, sort points so that
  	// the track starts at the top
  	// which point is further up in Y coord?
  	// start or end?
  	auto const&N = track.NumberTrajectoryPoints();
  	auto const&start = track.LocationAtPoint(0);
  	auto const&end   = track.LocationAtPoint( N - 1 );

  	// if points are ordered correctly
  	if (start.Y() > end.Y()){
    		for (size_t i=0; i < N; i++)
      		sorted_trk.push_back( track.LocationAtPoint(i) );
  		}
  
 	// otherwise flip order
  	else {
    	for (size_t i=0; i < N; i++)
      		sorted_trk.push_back( track.LocationAtPoint( N - i - 1) );
  	}
	*/
}
void T0RecoSCECalibrations::SplitTrack(const recob::Track& track, std::vector<TVector3>& split_trk){

	split_trk.clear();
	
	TVector3 track_neg, track_neg_c, track_pos_c,track_pos;
	double neg_x = 0.0;
	double pos_x = 0.0;
	double neg_c = -2.0*fTPCResolution;
	double pos_c = 2.0*fTPCResolution;
	
	for (size_t ii = 0; ii < track.NumberTrajectoryPoints(); ii++){
		auto const& trk_loc = track.LocationAtPoint(ii);
		
		if ((trk_loc.X() < -998.)||(trk_loc.Y() < -998.)||(trk_loc.Z() < -998)) continue;
		
		if (trk_loc.X() < neg_x){
			neg_x = trk_loc.X();
			track_neg = {trk_loc.X(), trk_loc.Y(), trk_loc.Z()};
		}
		if (trk_loc.X() > pos_x){
			pos_x = trk_loc.X();
			track_pos = {trk_loc.X(), trk_loc.Y(), trk_loc.Z()};
		}
		if ((trk_loc.X() < 0.0) && (trk_loc.X() > neg_c)){
			neg_c = trk_loc.X();
			track_neg_c = {trk_loc.X(), trk_loc.Y(), trk_loc.Z()};
		}
		if ((trk_loc.X() > 0.0) && (trk_loc.X() < pos_c)){
			pos_c = trk_loc.X();
			track_pos_c = {trk_loc.X(), trk_loc.Y(), trk_loc.Z()};
		}
	}
	
	if( track_neg.Y() > track_pos.Y()){
		split_trk.push_back(track_neg);
		split_trk.push_back(track_neg_c);
		split_trk.push_back(track_pos_c);
		split_trk.push_back(track_pos);
	} else {
		split_trk.push_back(track_pos);
		split_trk.push_back(track_pos_c);
		split_trk.push_back(track_neg_c);
		split_trk.push_back(track_neg);
	}
	
}
  
size_t  T0RecoSCECalibrations::FlashMatch(const double reco_time, std::vector<double> flash_times_v){
  
  	// loop through all reco'd flash times and see if one matches
  	// the time from the track/particle
  	double dt_min = 20000.; // us
  	size_t matched_flash_id;

    	_flash_time = 4999;
	_corrected_flash_time = -4999;
	_flash_pe = -9;
	_flash_centre_y = -9;
	_flash_centre_z = -9;
	_flash_width_y = -9;
	_flash_width_z = -9;
	_flash_time_width = -9;	

  	for (size_t i=0; i < flash_times_v.size(); i++){
		double _flash_time_i = flash_times_v[i];
    		double _corrected_flash_time_i = _flash_time_i*fFlashScaleFactor + fFlashTPCOffset;
    		_corrected_flash_reco_time_diff = _corrected_flash_time_i - reco_time;
    		if (fabs(_corrected_flash_reco_time_diff) < dt_min){
      			dt_min  = fabs(_corrected_flash_reco_time_diff);
      			matched_flash_id = _flash_id_v[i];
    		}

		if (fAllFlash) {
		const art::Ptr<recob::OpFlash> flash_i_ptr(flash_h, _flash_id_v[i]);
    		_flash_time = _flash_time_i;
		_corrected_flash_time = _corrected_flash_time_i;
		_flash_pe = flash_i_ptr->TotalPE();
		_flash_centre_y = flash_i_ptr->YCenter();
		_flash_centre_z = flash_i_ptr->ZCenter();
		_flash_width_y = flash_i_ptr->YWidth();
		_flash_width_z = flash_i_ptr->ZWidth();
		_flash_time_width = flash_i_ptr->TimeWidth() - flash_i_ptr->Time();
		_flash_tree->Fill();
		}

		
  	}
  	return matched_flash_id;
}

// Not used with pandora reconstruction
double T0RecoSCECalibrations::MatchTracks(std::vector<TVector3>& sorted_trk, std::vector<TLorentzVector> mcpart)
{
  //assumes both the reco track
  //and mctrack are downwards going
  
  //auto const& mctrk_s = mcpart.at(0);
  //auto const& mctrk_e = mcpart.at(1);
  //auto const& track_s = sorted_trk.at(0);
  //auto const& track_e = sorted_trk.at(sorted_trk.size()-1);
  
  double mcX_start = mcpart.at(0).X(), mcY_start = mcpart.at(0).Y(), mcZ_start = mcpart.at(0).Z();
  double mcX_end = mcpart.at(1).X(), mcY_end = mcpart.at(1).Y(), mcZ_end = mcpart.at(1).Z();
  double trkX_start = sorted_trk.at(0).X(), trkY_start = sorted_trk.at(0).Y(), trkZ_start = sorted_trk.at(0).Z();
  double trkX_end = sorted_trk.at(sorted_trk.size()-1).X(), trkY_end = sorted_trk.at(sorted_trk.size()-1).Y(), trkZ_end = sorted_trk.at(sorted_trk.size()-1).Z();
  
  if(mcY_start<mcY_end){
  	double tmpX = mcX_start, tmpY = mcY_start, tmpZ = mcZ_start;
  	mcX_start = mcX_end;
  	mcY_start = mcY_end;
  	mcZ_start = mcZ_end;
  	mcX_end = tmpX;
  	mcY_end = tmpY;
  	mcZ_end = tmpZ;
  }
  
  double trkThXZ = atan((trkZ_end - trkZ_start)/(trkX_end - trkX_start));
  double trkThYZ = atan((trkZ_end - trkZ_start)/(trkY_end - trkY_start));
  double sigThXZ = sqrt(2.0)*fTPCResolution/sqrt(pow(trkZ_end-trkZ_start,2.0)+pow(trkX_end-trkX_start,2.0));
  double sigThYZ = sqrt(2.0)*fTPCResolution/sqrt(pow(trkZ_end-trkZ_start,2.0)+pow(trkY_end-trkY_start,2.0));
  double mcThXZ = atan((mcZ_end - mcZ_start)/(mcX_end - mcX_start ));
  double mcThYZ = atan((mcZ_end - mcZ_start)/(mcY_end - mcY_start));
  
  return sqrt(pow((trkThXZ -  mcThXZ)/sigThXZ,2.0) + pow((trkThYZ -  mcThYZ)/sigThYZ,2.0) + pow((trkY_start - mcY_start)/fTPCResolution,2.0) + pow((trkZ_start - mcZ_start)/fTPCResolution,2.0))/4.0;

  
  
/*
  // if track start is above and mctrk start is above
  if ( ( track_s.Y() > track_e.Y() ) and ( mctrk_s.Y() > mctrk_e.Y() ) ){
    if ( (fabs(mctrk_s.Y()-track_s.Y()) < res) and (fabs(mctrk_s.Z()-track_s.Z()) < res) and (fabs(mctrk_e.Y()-track_e.Y()) < res) and (fabs(mctrk_e.Z()-track_e.Z()) < res) )
      return true;
  }
  // if track start is above and mctrk start is below
  if ( ( track_s.Y() > track_e.Y() ) and ( mctrk_s.Y() < mctrk_e.Y() ) ){
    if ( (fabs(mctrk_e.Y()-track_s.Y()) < res) and (fabs(mctrk_e.Z()-track_s.Z()) < res) and (fabs(mctrk_s.Y()-track_e.Y()) < res) and (fabs(mctrk_s.Z() - track_e.Z()) < res) )
      return true;
  }
  // if track start is below and mctrk start is above
  if ( ( track_s.Y() < track_e.Y() ) and ( mctrk_s.Y() > mctrk_e.Y() ) ){
    if ( (fabs(mctrk_s.Y()-track_e.Y()) < res) and (fabs(mctrk_s.Z()-track_e.Z()) < res) and (fabs(mctrk_e.Y()-track_s.Y()) < res) and (fabs(mctrk_e.Z()-track_s.Z()) < res) )
      return true;
  }
  // if track start is below and mctrk start is below
  if ( ( track_s.Y() < track_e.Y() ) and ( mctrk_s.Y() < mctrk_e.Y() ) ){
    if ( (fabs(mctrk_e.Y()-track_e.Y()) < res) and (fabs(mctrk_e.Z()-track_e.Z()) < res) and (fabs(mctrk_s.Y() - track_s.Y()) < res) and (fabs(mctrk_s.Z()-track_s.Z()) < res) )
      return true;
  }
  
  return false;
  */
}

DEFINE_ART_MODULE(T0RecoSCECalibrations) 
  
