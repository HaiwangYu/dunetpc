////////////////////////////////////////////////////////////////////////
// Class:       T0RecoAnodeCathodePiercingAna
// Module Type: analyzer
// File:        T0RecoAnodeCathodePiercingAna_module.cc
//
// Generated at Wed Jul 13 20:22:39 2016
// Authors: David Caratelli and Chris Barnes
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "canvas/Utilities/InputTag.h"
#include "art/Framework/Services/Optional/TFileService.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

// services etc...
#include "larcore/Geometry/Geometry.h"
#include "lardata/DetectorInfoServices/DetectorPropertiesService.h"
#include "larsim/MCCheater/BackTrackerService.h"
#include "larsim/MCCheater/ParticleInventoryService.h"

// data-products
#include "lardataobj/RecoBase/Track.h"
#include "lardataobj/RecoBase/Hit.h"
#include "lardataobj/AnalysisBase/T0.h"
#include "lardataobj/AnalysisBase/CosmicTag.h"
#include "lardataobj/AnalysisBase/Calorimetry.h"
#include "lardataobj/MCBase/MCTrack.h"
#include "lardataobj/RecoBase/OpFlash.h"
#include "nusimdata/SimulationBase/MCParticle.h"
#include "lardata/Utilities/AssociationUtil.h"

// C++
#include <memory>
#include <iostream>
#include <math.h>

// ROOT
#include <TTree.h>

class T0RecoAnodeCathodePiercingAna;

class T0RecoAnodeCathodePiercingAna : public art::EDAnalyzer {
public:
  explicit T0RecoAnodeCathodePiercingAna(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  T0RecoAnodeCathodePiercingAna(T0RecoAnodeCathodePiercingAna const &) = delete;
  T0RecoAnodeCathodePiercingAna(T0RecoAnodeCathodePiercingAna &&) = delete;
  T0RecoAnodeCathodePiercingAna & operator = (T0RecoAnodeCathodePiercingAna const &) = delete;
  T0RecoAnodeCathodePiercingAna & operator = (T0RecoAnodeCathodePiercingAna &&) = delete;

  void beginJob() override;

  // Required functions.
  void analyze(art::Event const & e) override;


private:

  // Declare member data here.
  std::string fTrackProducer;
  std::string fT0Producer;
  std::string fFlashProducer;
  std::string fCaloProducer;
  std::string fHitProducer;
  std::string fCosmicTagProducer;

  bool        fUseMC;
  double      fResolution; // cm resolution to allow mc-reco track matching. [Y,Z] must be within this distance

  // debug mode?
  bool _debug;
  bool _particle;

  // define top, bottom, front and back boundaries of TPC
  double _TOP, _BOTTOM, _FRONT, _BACK,_det_width;

  double fDriftVelocity;

  TTree* _tree;
  double _mc_time;
  double _cheat_t;
  double _rc_time;
  double _t_match;
  double _dt_flash;
  double _pe_flash;
  double _length;
  double _rc_x_start, _rc_x_end;
  double _rc_y_start, _rc_y_end;
  double _rc_z_start, _rc_z_end;
  double _mc_x_start, _mc_x_end;
  double _mc_y_start, _mc_y_end;
  double _mc_z_start, _mc_z_end;
  int    _matched;
  int    _anode;
  int    _cathode;
  int    _run, _subrun, _event,_track;
  int    _driftDir;

  TTree* _mucs_tree;
  double _reco_time;

  TTree* _calo_tree;
  float _x, _y, _z;
  float _x_corr;
  float _px, _py, _pz;
  float _dqds;
  double _t0;

  TTree* _2dhit_tree;
  float _mag;
  float _2d_adc;

  // functions to be used throughout module
  bool   TrackEntersTop     (const std::vector<TVector3>& sorted_trk);
  bool   TrackEntersFront   (const std::vector<TVector3>& sorted_trk);
  bool   TrackEntersBack    (const std::vector<TVector3>& sorted_trk);
  bool   TrackEntersAnode   (const std::vector<TVector3>& sorted_trk, const int driftDir);
  bool   TrackEntersSide    (const std::vector<TVector3>& sorted_trk);
  bool   TrackExitsBottom   (const std::vector<TVector3>& sorted_trk);
  bool   TrackExitsFront    (const std::vector<TVector3>& sorted_trk);
  bool   TrackExitsBack     (const std::vector<TVector3>& sorted_trk);
  bool   TrackExitsAnode    (const std::vector<TVector3>& sorted_trk, const int driftDir);
  bool   TrackExitsSide     (const std::vector<TVector3>& sorted_trk);

  // functions to be used for organization in the module
  void   SortTrackPoints(const recob::Track& track,std::vector<TVector3>& sorted_trk);

  double MatchTracks(std::vector<TVector3>& sorted_trk, std::vector<TLorentzVector> mcpart);
  
  std::vector<std::vector< TLorentzVector >> BuildMCParticleList(const art::Handle<std::vector<simb::MCParticle> > mcpart_h, const double& fResolution, const double& width);

};


T0RecoAnodeCathodePiercingAna::T0RecoAnodeCathodePiercingAna(fhicl::ParameterSet const & p)
  :
  EDAnalyzer(p)
{
  fTrackProducer     = p.get<std::string>("TrackProducer"    );
  fT0Producer        = p.get<std::string>("T0Producer"       );
  fFlashProducer     = p.get<std::string>("FlashProducer"    );
  fCaloProducer      = p.get<std::string>("CaloProducer"     );
  fHitProducer       = p.get<std::string>("HitProducer"      );
  fCosmicTagProducer = p.get<std::string>("CosmicTagProducer");
  fUseMC             = p.get<bool>       ("UseMC"            );
  fResolution        = p.get<double>     ("Resolution"       );
  _debug             = p.get<bool>       ("debug"            );
  _particle          = p.get<bool>       ("PrintParticles"   );

  // get boundaries based on detector bounds
  auto const* geom = lar::providerFrom<geo::Geometry>();
  
  _TOP = fResolution;
  _BOTTOM = fResolution;
  _FRONT = fResolution;
  _BACK = fResolution;

  for (geo::TPCID const& tID: geom->IterateTPCIDs()) {
   geo::TPCGeo const& TPC = geom->TPC(tID);
   
   if(TPC.DriftDistance() < 25.0) continue;
   
   double origin[3] = {0.};
   double center[3] = {0.};
   TPC.LocalToWorld(origin, center);
   
   double top = center[1] + TPC.HalfHeight() - fResolution;
   double bottom = center[1] - TPC.HalfHeight() + fResolution;
   double front = center[2] - TPC.HalfLength() + fResolution;
   double back = center[2] + TPC.HalfLength() - fResolution;
   
   if (top > _TOP) _TOP = top;
   if (bottom < _BOTTOM) _BOTTOM = bottom;
   if (front < _FRONT) _FRONT = front;
   if (back  > _BACK) _BACK = back;  
   
   _det_width = TPC.DriftDistance();
 }

}

void T0RecoAnodeCathodePiercingAna::beginJob()
{

  art::ServiceHandle<art::TFileService> tfs;
  _tree = tfs->make<TTree>("_tree","T0 reco performance");
  _tree->Branch("_mc_time",&_mc_time,"mc_time/D");
  _tree->Branch("_cheat_t",&_cheat_t,"cheat_t/D");
  _tree->Branch("_rc_time",&_rc_time,"rc_time/D");
  _tree->Branch("_t_match",&_t_match,"t_match/D");
  _tree->Branch("_dt_flash",&_dt_flash,"dt_flash/D");
  _tree->Branch("_pe_flash",&_pe_flash,"pe_flash/D");
  _tree->Branch("_length", &_length, "length/D");
  _tree->Branch("_matched",&_matched,"matched/I");
  _tree->Branch("_driftDir",&_driftDir,"driftDir/I");
  // Add branches for the first and last x, y, and z coordinates of the rc tracks and the mc tracks
  _tree->Branch("_mc_x_start",&_mc_x_start,"mc_x_start/D");
  _tree->Branch("_mc_y_start",&_mc_y_start,"mc_y_start/D");
  _tree->Branch("_mc_z_start",&_mc_z_start,"mc_z_start/D");
  _tree->Branch("_mc_x_end",&_mc_x_end,"mc_x_end/D");
  _tree->Branch("_mc_y_end",&_mc_y_end,"mc_y_end/D");
  _tree->Branch("_mc_z_end",&_mc_z_end,"mc_z_end/D");
  _tree->Branch("_rc_x_start",&_rc_x_start,"rc_x_start/D");
  _tree->Branch("_rc_y_start",&_rc_y_start,"rc_y_start/D");
  _tree->Branch("_rc_z_start",&_rc_z_start,"rc_z_start/D");
  _tree->Branch("_rc_x_end",&_rc_x_end,"rc_x_end/D");
  _tree->Branch("_rc_y_end",&_rc_y_end,"rc_y_end/D");
  _tree->Branch("_rc_z_end",&_rc_z_end,"rc_z_end/D");
  // information on whether track enters/exits which sides
  _tree->Branch("_anode"  ,&_anode  ,"anode/I"  );
  _tree->Branch("_cathode",&_cathode,"cathode/I");
  _tree->Branch("_run",&_run,"run/I");
  _tree->Branch("_subrun",&_subrun,"subrun/I");
  _tree->Branch("_event",&_event,"event/I");
  _tree->Branch("_track",&_track,"track/I");

  _mucs_tree = tfs->make<TTree>("_mucs_tree","MuCS tagged tracks tree");
  _mucs_tree->Branch("_reco_time",&_reco_time,"reco_time/D");
  _mucs_tree->Branch("_length", &_length, "length/D");
  _mucs_tree->Branch("_t_match",&_t_match,"t_match/D");
  _mucs_tree->Branch("_dt_flash",&_dt_flash,"dt_flash/D");
  _mucs_tree->Branch("_pe_flash",&_pe_flash,"pe_flash/D");
  _mucs_tree->Branch("_rc_x_start",&_rc_x_start,"rc_x_start/D");
  _mucs_tree->Branch("_rc_y_start",&_rc_y_start,"rc_y_start/D");
  _mucs_tree->Branch("_rc_z_start",&_rc_z_start,"rc_z_start/D");
  _mucs_tree->Branch("_rc_x_end",&_rc_x_end,"rc_x_end/D");
  _mucs_tree->Branch("_rc_y_end",&_rc_y_end,"rc_y_end/D");
  _mucs_tree->Branch("_rc_z_end",&_rc_z_end,"rc_z_end/D");
  _mucs_tree->Branch("_anode"  ,&_anode  ,"anode/I"  );
  _mucs_tree->Branch("_cathode",&_cathode,"cathode/I");
  _mucs_tree->Branch("_run",&_run,"run/I");
  _mucs_tree->Branch("_subrun",&_subrun,"subrun/I");
  _mucs_tree->Branch("_event",&_event,"event/I");

  _calo_tree = tfs->make<TTree>("_calo_tree","Track Calorimetry TTree");
  _calo_tree->Branch("_x",&_x,"x/F");
  _calo_tree->Branch("_x_corr",&_x_corr,"x_corr/F");
  _calo_tree->Branch("_y",&_y,"y/F");
  _calo_tree->Branch("_z",&_z,"z/F");
  _calo_tree->Branch("_px",&_px,"px/F");
  _calo_tree->Branch("_py",&_py,"py/F");
  _calo_tree->Branch("_pz",&_pz,"pz/F");
  _calo_tree->Branch("_t0",&_t0,"t0/D");
  _calo_tree->Branch("_run",&_run,"run/I");
  _calo_tree->Branch("_dqds",&_dqds,"dqds/F");

  _2dhit_tree = tfs->make<TTree>("_2dhit_tree","2D Track Calorimetry TTree");
  _2dhit_tree->Branch("_mag",&_mag,"mag/F"); // track length measured as distance from entering to exiting point
  _2dhit_tree->Branch("_2d_adc",&_2d_adc,"2d_adc/F");
  _2dhit_tree->Branch("_rc_x_start",&_rc_x_start,"rc_x_start/D");
  _2dhit_tree->Branch("_rc_y_start",&_rc_y_start,"rc_y_start/D");
  _2dhit_tree->Branch("_rc_z_start",&_rc_z_start,"rc_z_start/D");
  _2dhit_tree->Branch("_rc_x_end",&_rc_x_end,"rc_x_end/D");
  _2dhit_tree->Branch("_rc_y_end",&_rc_y_end,"rc_y_end/D");
  _2dhit_tree->Branch("_rc_z_end",&_rc_z_end,"rc_z_end/D");
  _2dhit_tree->Branch("_t0",&_t0,"t0/D");

  // Use '_detp' to find 'efield' and 'temp'
  auto const* _detp = lar::providerFrom<detinfo::DetectorPropertiesService>();
  double efield = _detp -> Efield();
  double temp   = _detp -> Temperature();
  // Determine the drift velocity from 'efield' and 'temp'
  fDriftVelocity = _detp -> DriftVelocity(efield,temp);

}

void T0RecoAnodeCathodePiercingAna::analyze(art::Event const & e)
{

  _event  = e.event();
  _subrun = e.subRun();
  _run    = e.run();
  std::vector<std::vector<TLorentzVector>> mcpart_list;

  // Implementation of required member function here.

  // load tracks previously created for which T0 reconstruction is requested
  art::Handle<std::vector<recob::Track> > track_h;
  e.getByLabel( fTrackProducer , track_h );
  
  // make sure tracks look good
  if(!track_h.isValid()) {
    std::cerr<<"\033[93m[ERROR]\033[00m ... could not locate Track!"<<std::endl;
    throw std::exception();
  }

  // load MCParticles
  art::Handle<std::vector<simb::MCParticle> > mcpart_h;
  e.getByLabel("largeant",mcpart_h);

  // if we should use MCParticle
  if (fUseMC){
    // make sure particles exist
    if(!mcpart_h.isValid()) {
      std::cerr<<"\033[93m[ERROR]\033[00m ... could not locate MCParticle!"<<std::endl;
      throw std::exception();
    }
    
     mcpart_list = BuildMCParticleList(mcpart_h,fResolution,_det_width); 
  }// if use MCParticle

  // grab T0 objects associated with tracks
  art::FindMany<anab::T0> trk_t0_assn_v(track_h, e, fT0Producer );

  // grab flashes associated with tracks
  art::FindMany<recob::OpFlash> trk_flash_assn_v(track_h, e, fFlashProducer );

  // grab calorimetry associated with tracks
  art::FindMany<anab::Calorimetry> trk_calo_assn_v(track_h, e, fCaloProducer );

  // grab 2d hits associated with tracks
  art::FindMany<recob::Hit> trk_hit_assn_v(track_h, e, fHitProducer);
  art::FindManyP<recob::Hit> trk_hit_assn_v_ptr(track_h, e, fHitProducer);

  if (_debug)
    std::cout << "There are " << trk_flash_assn_v.size() << " track -> flash associations" << std::endl;

  // grab CosmicTag objects associated with tracks
  art::FindMany<anab::CosmicTag> trk_cosmictag_assn_v(track_h, e, fCosmicTagProducer);

  if (_debug)
    std::cout << "There are " << trk_cosmictag_assn_v.size() << " track -> cosmictag associations" << std::endl;

  for (size_t i=0; i < track_h->size(); i++){
  
  if(_debug) std::cout << "Reco track " << i << std::endl;

    auto const& track = track_h->at(i);

	auto const* geom = lar::providerFrom<geo::Geometry>();
    const std::vector<const recob::Hit*>& Hit_v = trk_hit_assn_v.at(i);
    
    _track = i;
	
	// Determine if the track crosses the cathode    
    auto const* hit = Hit_v.at(0);
    const geo::WireID wireID = hit->WireID();
	const auto TPCGeoObject = geom->TPC(wireID.TPC,wireID.Cryostat);
	short int driftDir = TPCGeoObject.DetectDriftDirection();
	bool cross_cathode = false;
    for (size_t ii = 1; ii < Hit_v.size(); ii++) {
    	const geo::WireID wireID2 = Hit_v.at(ii)->WireID();
		const auto TPCGeoObject2 = geom->TPC(wireID2.TPC,wireID2.Cryostat);
		short int driftDir_tmp = TPCGeoObject2.DetectDriftDirection(); 
		
		if(driftDir_tmp + driftDir == 0){
			cross_cathode = true;
			continue;
		}
	}
	
	_driftDir = driftDir;
	
	if(cross_cathode){ 
	  if(_debug) std::cout << "\tCathode crossing track! No need to continue." << std::endl; 
	  continue;
	}

    _matched = 0;

    const std::vector<const anab::T0*>& T0_v = trk_t0_assn_v.at(i);

    if (_debug)
      std::cout << "\t" << T0_v.size() << " T0 objects associated to this track" << std::endl;

    const std::vector<const recob::OpFlash*>& flash_v = trk_flash_assn_v.at(i);

    if (_debug)
      std::cout << "\t" << flash_v.size() << " flash objects associated to this track" << std::endl;

    // grab T0 object
    if (T0_v.size() == 1){

      auto t0 = T0_v.at(0);

      // get sorted points for the track object [assuming downwards going]
      std::vector<TVector3> sorted_trk;
      SortTrackPoints(track,sorted_trk);

      auto const& top    = sorted_trk.at(0);
      auto const& bottom = sorted_trk.at(sorted_trk.size() - 1);
      
      _rc_x_start = top.X();
      _rc_y_start = top.Y();
      _rc_z_start = top.Z();
      _rc_x_end   = bottom.X();
      _rc_y_end   = bottom.Y();
      _rc_z_end   = bottom.Z();
      _length     = track.Length();
      _mag = sqrt( ( (_rc_x_end - _rc_x_start) * (_rc_x_end - _rc_x_start) ) +
		   ( (_rc_y_end - _rc_y_start) * (_rc_y_end - _rc_y_start) ) +
		   ( (_rc_z_end - _rc_z_start) * (_rc_z_end - _rc_z_start) ) );
      _px = (_rc_x_end - _rc_x_start) / _mag;
      _py = (_rc_y_end - _rc_y_start) / _mag;
      _pz = (_rc_z_end - _rc_z_start) / _mag;

      _anode = _cathode = 0;

      if ( (TrackExitsBottom(sorted_trk) == true) && (TrackEntersAnode(sorted_trk, driftDir) == true)  ) { _anode = 1; _cathode = 0; }
      if ( (TrackExitsBottom(sorted_trk) == true) && (TrackEntersAnode(sorted_trk, driftDir) == false) ) { _anode = 0; _cathode = 1; }
      if ( (TrackEntersTop(sorted_trk) == true)   && (TrackExitsAnode(sorted_trk, driftDir) == true)   ) { _anode = 1; _cathode = 0; }
      if ( (TrackEntersTop(sorted_trk) == true)   && (TrackExitsAnode(sorted_trk, driftDir) == false)  ) { _anode = 0; _cathode = 1; }
      if ( (TrackExitsFront(sorted_trk) == true)  && (TrackEntersAnode(sorted_trk, driftDir) == true)  ) { _anode = 1; _cathode = 0; }
      if ( (TrackExitsFront(sorted_trk) == true) && (TrackEntersAnode(sorted_trk, driftDir) == false)  ) { _anode = 0; _cathode = 1; }
      if ( (TrackEntersFront(sorted_trk) == true) && (TrackExitsAnode(sorted_trk, driftDir) == true)  ) { _anode = 1; _cathode = 0; }
      if ( (TrackEntersFront(sorted_trk) == true) && (TrackExitsAnode(sorted_trk, driftDir) == false)  ) { _anode = 0; _cathode = 1; }
      if ( (TrackExitsBack(sorted_trk) == true)  && (TrackEntersAnode(sorted_trk, driftDir) == true)  ) { _anode = 1; _cathode = 0; }
      if ( (TrackExitsBack(sorted_trk) == true) && (TrackEntersAnode(sorted_trk, driftDir) == false)  ) { _anode = 0; _cathode = 1; }
      if ( (TrackEntersBack(sorted_trk) == true) && (TrackExitsAnode(sorted_trk, driftDir) == true)  ) { _anode = 1; _cathode = 0; }
      if ( (TrackEntersBack(sorted_trk) == true) && (TrackExitsAnode(sorted_trk, driftDir) == false)  ) { _anode = 0; _cathode = 1; }
      
      

      // reconstructed time comes from T0 object
      _rc_time = t0->Time();

      // if there is an associated optical flash
      if (flash_v.size() == 1){
	
	auto flash = flash_v.at(0);
	
	_pe_flash = flash->TotalPE();
	_t_match  = flash->Time();
	//_dt_flash = fabs( flash->Time() - _rc_time );
    _dt_flash = flash->Time() - _rc_time;
      } // if there is an optical flash
      
      if(_debug) std::cout <<"This track goes from (" << sorted_trk.at(0).X() << ", " << sorted_trk.at(0).Y() << ", " << sorted_trk.at(0).Z() << ") -> (" << sorted_trk.at(sorted_trk.size()-1).X() << ", " << sorted_trk.at(sorted_trk.size()-1).Y() << ", " << sorted_trk.at(sorted_trk.size()-1).Z() << ")" << std::endl;

      // if we should use MC info -> continue w/ MC validation
      if (fUseMC == true){
	// loop through MCParticles to find the one that matches.
	_mc_time = 0;
	double _displacement = 1.0;
	
	art::ServiceHandle<cheat::BackTrackerService> bt_serv;
	art::ServiceHandle<cheat::ParticleInventoryService> pi_serv;
	
	std::vector<art::Ptr<recob::Hit>> allHits=trk_hit_assn_v_ptr.at(i);
	
    int trackid=-1;
    std::map<int,double> trkide;
    for(size_t h=0; h<allHits.size();h++){
		auto hit_ptr=allHits[h];
		std::vector<sim::TrackIDE> eveIDs = bt_serv->HitToTrackIDEs(hit_ptr);
		for(size_t e=0;e<eveIDs.size(); ++e){
	 		 trkide[eveIDs[e].trackID] += eveIDs[e].energy;
		}
      }
      
    double  maxe = -1;
    for(std::map<int,double>::iterator ii = trkide.begin(); ii!=trkide.end(); ++ii){
		if((ii->second)>maxe){
	  		maxe = ii->second;
	  		trackid = ii->first;
	 	}
	}
	
	const simb::MCParticle *particle = pi_serv->TrackIdToParticle_P(trackid);

	if(_debug) std::cout << "\t\tCheat Particle t0 = " << particle->T(0)/1000.0 << std::endl;
	_cheat_t = particle->T(0)/1000.0;
	  
	for (size_t j=0; j < mcpart_list.size(); j++){
	  
	  std::vector<TLorentzVector> mcpart = mcpart_list.at(j);
	  
	  //if(_debug) std::cout <<"\t\tMCParticle: (" << mcpart.at(0).X() << ", " << mcpart.at(0).Y() << ", " << mcpart.at(0).Z() << ") -> (" << mcpart.at(1).X() << ", " << mcpart.at(1).Y() << ", " << mcpart.at(1).Z() << ")" << std::endl;
	  
	  // try matching to MC
	  double _tmp_disp = MatchTracks(sorted_trk, mcpart);
	  if ((_tmp_disp > _displacement)||isnan(_tmp_disp))
	    continue;
	  
	  // matched -> get MCTrack time and reconstructed track reconstructed T0
	  _displacement = _tmp_disp;
	  _mc_time = mcpart.at(0).T() / 1000.;
	  _matched = 1;

	  if(_debug) std::cout << "\tParticle number: " << j << " with sigma comparison value of " << _displacement << "\n\t\tTrack matched to MC value with t0 of " << _mc_time << ", flash t0 of " << _t_match << " and reconstructed time of " << _rc_time << std::endl;

	  // Here is where I'll set the coordinates for the start and end of the mc tracks
	  if(mcpart.at(0).Y() > mcpart.at(1).Y()){
		  _mc_x_start = mcpart.at(0).X();
		  _mc_y_start = mcpart.at(0).Y();
		  _mc_z_start = mcpart.at(0).Z();
		  _mc_x_end   = mcpart.at(1).X();
		  _mc_y_end   = mcpart.at(1).Y();
		  _mc_z_end   = mcpart.at(1).Z();
	  } else {
	  	  _mc_x_start = mcpart.at(1).X();
		  _mc_y_start = mcpart.at(1).Y();
		  _mc_z_start = mcpart.at(1).Z();
		  _mc_x_end   = mcpart.at(0).X();
		  _mc_y_end   = mcpart.at(0).Y();
		  _mc_z_end   = mcpart.at(0).Z();
	  
	  }
	  
	} // for all MCParticles
	  if(_debug&&!_matched) std::cout << "\tNo MC particle matched this track!" << std::endl;
      }// if we should use MCParticles
      
      _tree->Fill();
      
      // check if there is a cosmic tag, if so assume MuCS-tagged track
      std::vector<const anab::CosmicTag*> CosmicTag_v = trk_cosmictag_assn_v.at(i);
      
      if (CosmicTag_v.size() == 1){
	_reco_time = _rc_time;
	_mucs_tree->Fill();
      }// if there is a cosmic tag

      
      // fill calorimetry info for this track
      // grab the associated calorimetry object
      const std::vector<const anab::Calorimetry*>& Calo_v = trk_calo_assn_v.at(i);

      if (_debug) std::cout << "\tThere are " << Calo_v.size() << " Calorimetry objects associated with track " << i+1 << std::endl;

      for (size_t pl=0; pl < Calo_v.size(); pl++){
      
    auto const& calo = Calo_v.at(pl);
	
	auto const& plane = calo->PlaneID().Plane;
	if (_debug) std::cout << "\t\tPlane ID = " << plane << std::endl;

	if (plane == 2){
	  
	  _t0 = _rc_time;

	  if (_debug) std::cout << "\t\tPlane ID is " << plane << std::endl;
	  
	  // grab point-by-point information
	  auto const& dqdx_v = calo->dQdx();
	  auto const& xyz_v = calo->XYZ();

	  if (dqdx_v.size() != xyz_v.size()){
	    std::cout << "\t\tdQdx and XYZ vectors diagreee in size! skip track..." << std::endl;
	    continue;
	  }

	  for (size_t n=0; n < dqdx_v.size(); n++){

	    _dqds = dqdx_v[n];
	    _x = xyz_v[n].X();
	    _y = xyz_v[n].Y();
	    _z = xyz_v[n].Z();
	    _x_corr = _x - (_t0 * fDriftVelocity);

	    _calo_tree->Fill();
	    
	  }// for all calorimetry info

	}// if collection plane
	
      }// for all planes


      // fill 2dhit info for this track
      // grab the associated 2d hit object
      if (_debug) std::cout << "\tFinding hit associations" << std::endl;
      const std::vector<const recob::Hit*>& Hit_v = trk_hit_assn_v.at(i);

      _2d_adc = 0;

      for (size_t h=0; h < Hit_v.size(); h++){
	
	auto const& hit = Hit_v.at(h);
	
	if (hit->View() != geo::_plane_proj::kW) continue;
	
	_2d_adc += hit->Integral();
	
      }// for all hits

      _2dhit_tree->Fill();
      
    } // if there is a reconstructed T0
    
  } // for all reconstructed tracks
  
}



double T0RecoAnodeCathodePiercingAna::MatchTracks(std::vector<TVector3>& sorted_trk, std::vector<TLorentzVector> mcpart)
{
  //assumes both the reco track
  //and mctrack are downwards going
  
  //auto const& mctrk_s = mcpart.at(0);
  //auto const& mctrk_e = mcpart.at(1);
  //auto const& track_s = sorted_trk.at(0);
  //auto const& track_e = sorted_trk.at(sorted_trk.size()-1);
  
  double mcX = mcpart.at(0).X(), mcY = mcpart.at(0).Y(), mcZ = mcpart.at(0).Z();
  double mcX_end = mcpart.at(1).X(), mcY_end = mcpart.at(1).Y(), mcZ_end = mcpart.at(1).Z();
  double trkX = sorted_trk.at(0).X(), trkY = sorted_trk.at(0).Y(), trkZ = sorted_trk.at(0).Z();
  double trkX_end = sorted_trk.at(sorted_trk.size()-1).X(), trkY_end = sorted_trk.at(sorted_trk.size()-1).Y(), trkZ_end = sorted_trk.at(sorted_trk.size()-1).Z();
  
  if(mcY<mcY_end){
  	double tmpX = mcX, tmpY = mcY, tmpZ = mcZ;
  	mcX = mcX_end;
  	mcY = mcY_end;
  	mcZ = mcZ_end;
  	mcX_end = tmpX;
  	mcY_end = tmpY;
  	mcZ_end = tmpZ;
  }
  
  double trkThXZ = atan((trkZ_end - trkZ)/(trkX_end - trkX));
  double trkThYZ = atan((trkZ_end - trkZ)/(trkY_end - trkY));
  double sigThXZ = sqrt(2.0)*fResolution/sqrt(pow(trkZ_end-trkZ,2.0)+pow(trkX_end-trkX,2.0));
  double sigThYZ = sqrt(2.0)*fResolution/sqrt(pow(trkZ_end-trkZ,2.0)+pow(trkY_end-trkY,2.0));
  double mcThXZ = atan((mcZ_end - mcZ)/(mcX_end - mcX));
  double mcThYZ = atan((mcZ_end - mcZ)/(mcY_end - mcY));
  
  return sqrt(pow((trkThXZ -  mcThXZ)/sigThXZ,2.0) + pow((trkThYZ -  mcThYZ)/sigThYZ,2.0) + pow((trkY - mcY)/fResolution,2.0) + pow((trkZ - mcZ)/fResolution,2.0))/4.0;

  
  
/*
  // if track start is above and mctrk start is above
  if ( ( track_s.Y() > track_e.Y() ) and ( mctrk_s.Y() > mctrk_e.Y() ) ){
    if ( (fabs(mctrk_s.Y()-track_s.Y()) < res) and (fabs(mctrk_s.Z()-track_s.Z()) < res) and (fabs(mctrk_e.Y()-track_e.Y()) < res) and (fabs(mctrk_e.Z()-track_e.Z()) < res) )
      return true;
  }
  // if track start is above and mctrk start is below
  if ( ( track_s.Y() > track_e.Y() ) and ( mctrk_s.Y() < mctrk_e.Y() ) ){
    if ( (fabs(mctrk_e.Y()-track_s.Y()) < res) and (fabs(mctrk_e.Z()-track_s.Z()) < res) and (fabs(mctrk_s.Y()-track_e.Y()) < res) and (fabs(mctrk_s.Z() - track_e.Z()) < res) )
      return true;
  }
  // if track start is below and mctrk start is above
  if ( ( track_s.Y() < track_e.Y() ) and ( mctrk_s.Y() > mctrk_e.Y() ) ){
    if ( (fabs(mctrk_s.Y()-track_e.Y()) < res) and (fabs(mctrk_s.Z()-track_e.Z()) < res) and (fabs(mctrk_e.Y()-track_s.Y()) < res) and (fabs(mctrk_e.Z()-track_s.Z()) < res) )
      return true;
  }
  // if track start is below and mctrk start is below
  if ( ( track_s.Y() < track_e.Y() ) and ( mctrk_s.Y() < mctrk_e.Y() ) ){
    if ( (fabs(mctrk_e.Y()-track_e.Y()) < res) and (fabs(mctrk_e.Z()-track_e.Z()) < res) and (fabs(mctrk_s.Y() - track_s.Y()) < res) and (fabs(mctrk_s.Z()-track_s.Z()) < res) )
      return true;
  }
  
  return false;
  */
}


bool   T0RecoAnodeCathodePiercingAna::TrackEntersTop(const std::vector<TVector3>& sorted_trk)
{
  // check that the first point in the track
  // pierces the top boundary of the TPC
  // This track either will pierce the top of the TPC or is just about to (the '_TOP' variable is just below the actual coordinate position of the top in Y)

  if (sorted_trk.at(0).Y() > _TOP)
    return true;

  return false;
}

bool T0RecoAnodeCathodePiercingAna::TrackEntersFront(const std::vector<TVector3>& sorted_trk)
{

  // Determine if the track enters the
  // front of the TPC based on if the position
  // of its initial Z-coordinate is less than
  // the location of the front of the TPC in Z
  
  // First define 'top_pt' to mean the point at the start of the track
  auto const& top_pt = sorted_trk.at(0);

  if (top_pt.Z() < _FRONT)
    return true;

  // I may include the case in which I check
  // the y-coordinates as well, but I will not
  // implement that at this time
  
  // If this condition is not satisfied, then return 'false' (the track was not determined
  // within resolution to enter the front of the TPC)
  return false;
}


bool T0RecoAnodeCathodePiercingAna::TrackEntersBack(const std::vector<TVector3>& sorted_trk)
{

  // Determines if the track enters the
  // back of the TPC based on if the position
  // of its initial Z-coordinate is greater
  // than the location of the back of the
  // TPC in Z
  
  // First define 'top_pt' to mean the point at the start of the track
  auto const& top_pt = sorted_trk.at(0);

  if (top_pt.Z() > _BACK)
    return true;

  // If this condition is not satisfied, then return 'false' (the track was not determined
  // within resolution to enter the back of the TPC)
  return false;
}

bool   T0RecoAnodeCathodePiercingAna::TrackEntersAnode(const std::vector<TVector3>& sorted_trk, const int driftDir)
{

// we know the track enters either the anode or cathode
// at this point figure out if it ENTERS the ANODE or CATHODE
// ANODE: top point must be at lower X-coordinate than bottom point
// CATHODE: top point must be at larger X-coordinate than bottom point
// assume track has already been sorted such that the first point is
// the most elevated in Y-coordinate
// return TRUE if passes the ANODE

  auto const& top    = sorted_trk.at(0);
  auto const& bottom = sorted_trk.at( sorted_trk.size() - 1 );

  if (((top.X() < bottom.X()) && driftDir < 0)||((top.X() > bottom.X()) && driftDir > 0))
    return true;
  
  return false;
}


bool   T0RecoAnodeCathodePiercingAna::TrackEntersSide(const std::vector<TVector3>& sorted_trk)
{

// check that the top-most point is not the top of the TPC
// nor on the front or back of the TPC
  
  auto const& top_pt = sorted_trk.at(0);

  // if highest point above the TOP -> false
  if (top_pt.Y() > _TOP)
    return false;

  // if highest point in Z close to front or back -> FALSE 
  if ( (top_pt.Z() < _FRONT) or (top_pt.Z() > _BACK) )
    return false;


  // If the function makes it this far, then it will enter through one of the sides of the TPC
  return true;
}

bool   T0RecoAnodeCathodePiercingAna::TrackExitsBottom(const std::vector<TVector3>& sorted_trk)
{

  // check that the last point in the track
  // pierces the bottom boundary of the TPC
  if ( sorted_trk.at( sorted_trk.size() - 1).Y() < _BOTTOM )
    return true;

  return false;
}

bool   T0RecoAnodeCathodePiercingAna::TrackExitsFront(const std::vector<TVector3>& sorted_trk)
{

  // Determine if the track exits the
  // front of the TPC based on if the position
  // of its final Z-coordinate is less than
  // the location of the front of the TPC in Z
  
  // First define 'bottom_pt' to mean the point at the end of the track
  auto const& bottom_pt = sorted_trk.at(sorted_trk.size() - 1);

  if (bottom_pt.Z() < _FRONT)
    return true;
  
  return false;
}


bool   T0RecoAnodeCathodePiercingAna::TrackExitsBack(const std::vector<TVector3>& sorted_trk)
{

  // Determine if the track exits the
  // front of the TPC based on if the position
  // of its final Z-coordinate is less than
  // the location of the front of the TPC in Z
  
  // First define 'bottom_pt' to mean the point at the end of the track
  auto const& bottom_pt = sorted_trk.at(sorted_trk.size() - 1);

  if (bottom_pt.Z() > _BACK)
    return true;

  return false;
}

bool   T0RecoAnodeCathodePiercingAna::TrackExitsAnode(const std::vector<TVector3>& sorted_trk, const int driftDir)
{

  // Check, once it's known that the track doesn't exit out of the bottom, whether it's the anode or
  // the cathode that it exits out of
  // This can be done by direct analogy with the 'Anode' function (shown in this file as the 'TrackEntersAnode') function written by D. Caratelli
  // Define 'top' as the point at the start of the track, and 'bottom' as the point at the end of the track

  auto const& top    = sorted_trk.at(0);
  auto const& bottom = sorted_trk.at(sorted_trk.size() - 1);

  // Check to see which point has a lower x coordinate
  // If the bottom does, then it exits out of the anode
  // If the top does, then it exits out of the cathode
  if (((bottom.X() < top.X()) && driftDir < 0) || ((bottom.X() > top.X()) && driftDir > 0))
    return true;

  return false; // Otherwise, the top is less than the bottom, so the track ended closer to the cathode and exited there
}


bool   T0RecoAnodeCathodePiercingAna::TrackExitsSide(const std::vector<TVector3>& sorted_trk)
{

  // check that the bottom-most point
  // is not on the bottom of the TPC
  // nor on the front & back of the TPC

  auto const& bottom_pt = sorted_trk.at(sorted_trk.size() - 1);

  // if lowest point below the BOTTOM -> false
  // Within this resolution, this means that it's likely that the track exited out of the bottom (at a point earlier on in the process than the last point) OR is just about to

  if (bottom_pt.Y() <  _BOTTOM)
    return false;

  // if lowest point in Z close to front or back
  // -> FALSE
  // If the the bottom point is less than the front, then the track has already pierced the front of the TPC and exited that way OR is likely just about to
  // If the bottom point is greater than the back, then the track has already pierced the back of the TPC and exited that way OR is likely just about to
  if ( (bottom_pt.Z() < _FRONT) or (bottom_pt.Z() > _BACK) )
    return false;

  return true;
}

void   T0RecoAnodeCathodePiercingAna::SortTrackPoints(const recob::Track& track, std::vector<TVector3>& sorted_trk)
{

	sorted_trk.clear();
	
	TVector3 track_start, track_end;	
	double start_y = _BOTTOM - 2.0*fResolution;
	double end_y = _TOP + 2.0*fResolution;
	
	for (size_t ii = 0; ii < track.NumberTrajectoryPoints(); ii++){
		auto const& trk_loc = track.LocationAtPoint(ii);
		if (trk_loc.Y() < end_y){
			end_y = trk_loc.Y();
			track_end = {trk_loc.X(), trk_loc.Y(), trk_loc.Z()};
		}
		if (trk_loc.Y() > start_y){
			start_y = trk_loc.Y();
			track_start = {trk_loc.X(), trk_loc.Y(), trk_loc.Z()};
		}
	}
	
	sorted_trk.push_back(track_start);
	sorted_trk.push_back(track_end);



/*
  // vector to store 3D coordinates of
  // ordered track
  sorted_trk.clear();

  // take the reconstructed 3D track
  // and assuming it is downwards
  // going, sort points so that
  // the track starts at the top
  // which point is further up in Y coord?
  // start or end?
  auto const&N = track.NumberTrajectoryPoints();
  auto const&start = track.LocationAtPoint(0);
  auto const&end   = track.LocationAtPoint( N - 1 );

  // if points are ordered correctly
  if (start.Y() > end.Y()){
    for (size_t i=0; i < N; i++)
      sorted_trk.push_back( track.LocationAtPoint(i) );
  }
  
  // otherwise flip order
  else {
    for (size_t i=0; i < N; i++)
      sorted_trk.push_back( track.LocationAtPoint( N - i - 1) );
  }
*/  
  
}

std::vector<std::vector< TLorentzVector >> T0RecoAnodeCathodePiercingAna::BuildMCParticleList(const art::Handle<std::vector<simb::MCParticle> > mcpart_h,const double& fResolution, const double& width){

	std::vector<std::vector< TLorentzVector>> mcVec;

	for (size_t j=0; j < mcpart_h->size(); j++){
			
		auto const& mcpart = mcpart_h->at(j);
		
		double x0 = mcpart.Position(0).X();
		double y0 = mcpart.Position(0).Y();
		double z0 = mcpart.Position(0).Z();
		double t0 = mcpart.T(0);
		double x1 = mcpart.Position(mcpart.NumberTrajectoryPoints()-1).X();
		double y1 = mcpart.Position(mcpart.NumberTrajectoryPoints()-1).Y();
		double z1 = mcpart.Position(mcpart.NumberTrajectoryPoints()-1).Z();
		double t1 = mcpart.T(mcpart.NumberTrajectoryPoints()-1);
		
		//double xs = x0, ys = y0, zs = z0, ts = t0;
		//double xe = x1, ye = y1, ze = z1, te = t1;
		
		bool top_ok = false, bot_ok = false;

		for(size_t k = 0; k<mcpart.NumberTrajectoryPoints(); k++){
			if ((x0 > width) || (x0 < -width) || (y0 > _TOP + fResolution) || (y0 < _BOTTOM - fResolution) || (z0 < _FRONT - fResolution) || (z0 > _BACK + fResolution) ){
				x0 = mcpart.Position(k+1).X();
				y0 = mcpart.Position(k+1).Y();
				z0 = mcpart.Position(k+1).Z();
				t0 = mcpart.T(k+1);
			} else top_ok = true;
			
			if ((x1 > width) || (x1 < -width) || (y1 > _TOP + fResolution) || (y1 < _BOTTOM - fResolution) || (z1 < _FRONT - fResolution) || (z1 > _BACK + fResolution) ){
				x1 = mcpart.Position(mcpart.NumberTrajectoryPoints()-2-k).X();
				y1 = mcpart.Position(mcpart.NumberTrajectoryPoints()-2-k).Y();
				z1 = mcpart.Position(mcpart.NumberTrajectoryPoints()-2-k).Z();
				t1 = mcpart.T(mcpart.NumberTrajectoryPoints()-2-k);
			} else bot_ok = true;
			
			if(top_ok&&bot_ok) continue;
		}
		
		
		/*double top = _TOP + fResolution, bottom = _BOTTOM - fResolution, back = _BACK + fResolution, front = _FRONT - fResolution;
		
		if(xs > width) {
			xs = width;
			ys = (width - x0)*(y1 - y0)/(x1 - x0) + y0;
			zs = (width - x0)*(z1 - z0)/(x1 - x0) + z0;
			ts = (width - x0)*(t1 - t0)/(x1 - x0) + t0;
		} else if (xs < - width){
			xs = -width;
			ys = (-width - x0)*(y1 - y0)/(x1 - x0) + y0;
			zs = (-width - x0)*(z1 - z0)/(x1 - x0) + z0;
			ts = (-width - x0)*(t1 - t0)/(x1 - x0) + t0;
		}
		
		if(ys > top){
			xs = (top - y0)*(x1 - x0)/(y1 - y0) + x0;
			ys = top;
			zs = (top - y0)*(z1 - z0)/(y1 - y0) + z0;
			ts = (top - y0)*(t1 - t0)/(y1 - y0) + t0;
		} else if (ys < bottom){
			xs = (bottom - y0)*(x1 - x0)/(y1 - y0) + x0;
			ys = bottom;
			zs = (bottom - y0)*(z1 - z0)/(y1 - y0) + z0;
			ts = (bottom - y0)*(t1 - t0)/(y1 - y0) + t0;
		}
		
		if(zs > back){
			xs = (back - z0)*(x1 - x0)/(z1 - z0) + x0;
			ys = (back - z0)*(y1 - y0)/(z1 - z0) + y0;
			zs = back;
			ts = (back - z0)*(t1 - t0)/(z1 - z0) + t0;
		} else if (zs < front){
			xs = (front - z0)*(x1 - x0)/(z1 - z0) + x0;
			ys = (front - z0)*(y1 - y0)/(z1 - z0) + y0;
			zs = front;
			ts = (front - z0)*(t1 - t0)/(z1 - z0) + t0;
		}
		
		if(xe > width) {
			xe = width;
			ye = (width - x0)*(y1 - y0)/(x1 - x0) + y0;
			ze = (width - x0)*(z1 - z0)/(x1 - x0) + z0;
			te = (width - x0)*(t1 - t0)/(x1 - x0) + t0;
		} else if (xe < - width){
			xe = -width;
			ye = (-width - x0)*(y1 - y0)/(x1 - x0) + y0;
			ze = (-width - x0)*(z1 - z0)/(x1 - x0) + z0;
			te = (-width - x0)*(t1 - t0)/(x1 - x0) + t0;
		}
		
		if(ye > top){
			xe = (top - y0)*(x1 - x0)/(y1 - y0) + x0;
			ye = top;
			ze = (top - y0)*(z1 - z0)/(y1 - y0) + z0;
			te = (top - y0)*(t1 - t0)/(y1 - y0) + t0;
		} else if (ye < bottom){
			xe = (bottom - y0)*(x1 - x0)/(y1 - y0) + x0;
			ye = bottom;
			ze = (bottom - y0)*(z1 - z0)/(y1 - y0) + z0;
			te = (bottom - y0)*(t1 - t0)/(y1 - y0) + t0;
		}
		
		if(ze > back){
			xe = (back - z0)*(x1 - x0)/(z1 - z0) + x0;
			ye = (back - z0)*(y1 - y0)/(z1 - z0) + y0;
			ze = back;
			te = (back - z0)*(t1 - t0)/(z1 - z0) + t0;
		} else if (ze < front){
			xe = (front - z0)*(x1 - x0)/(z1 - z0) + x0;
			ye = (front - z0)*(y1 - y0)/(z1 - z0) + y0;
			ze = front;
			te = (front - z0)*(t1 - t0)/(z1 - z0) + t0;
		}*/
			
		double xs = x0, ys = y0, zs = z0, ts = t0;
		double xe = x1, ye = y1, ze = z1, te = t1;
		
		TLorentzVector mc_top(TVector3(xs,ys,zs),ts);
		TLorentzVector mc_bot(TVector3(xe,ye,ze),te);
		
		//if (!top_ok||!bot_ok) continue;
		
		if (ys >  ye) mcVec.push_back({mc_top, mc_bot});
		else mcVec.push_back({mc_bot, mc_top});
		
		if(_debug&&_particle) std::cout << " MCParticle: (" << x0 << ", " << y0 << ", " << z0 << ", " << t0/1000. << ") --> (" << xs << ", " << ys << ", " << zs << ", " << ts/1000.0 << ") --> (" << xe << ", " << ye << ", " << ze << ", " << te/1000.0 << ") --> (" << x1 << ", " << y1 << ", " << z1 << ", " << t1/1000.0 << ")" << std::endl;
		
	}
		
		return mcVec;	

}

DEFINE_ART_MODULE(T0RecoAnodeCathodePiercingAna)
